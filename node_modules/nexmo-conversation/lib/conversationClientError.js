/**  
 * Conversation SDK
 *  Conversation CLient Error
 * 
 * Copyright (c) Nexmo Inc. 2017
 */

var NexmoClientErrorTypes = require('./conversationClientErrorTypes');

function decorateError(instance, error) {

	Object.assign(instance, error);
	instance.message = 'type: ' + instance.type + ', description: ' + (instance.description ? instance.description : '');
	instance.stack = new Error().stack;
}

/**
 * constructor
 * @param {string} errorInput string client error
 */
var NexmoClientError = function(errorInput) {
	error = NexmoClientErrorTypes[errorInput];
	// for other errors (libs/browser APIs) re-use the Client error 
	// to forward it but don't throw it away
	if (error) {
		// if error type exists in our list keep consistency
		decorateError(this, error);
	} else {
		//if the structure is not as expected, f/w as much as we can get
		this.message = errorInput.message || errorInput;
		this.stack = errorInput.stack || new Error().stack;
	}

	// make sure the error.name matches the class name
	this.name = 'NexmoClientError';
}

NexmoClientError.prototype = Object.create(NexmoClientError.prototype);
NexmoClientError.prototype.constructor = NexmoClientError;


/**
 * constructor
 * @param {object} backend error and always containg {type: <string>}
 */
var NexmoApiError = function(error) {

	decorateError(this, error);
	// make sure the error.name matches the class name
	this.name = 'NexmoApiError';
}

NexmoApiError.prototype = Object.create(NexmoApiError.prototype);
NexmoApiError.prototype.constructor = NexmoApiError;


module.exports = {
	NexmoClientError: NexmoClientError,
	NexmoApiError: NexmoApiError
}