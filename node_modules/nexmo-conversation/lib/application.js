/*
 * Conversation SDK
 *  Application object model
 *
 * Copyright (c) Nexmo Inc. 2015
 */

var WildEmitter = require('wildemitter');
var logger = require('loglevel');

var User = require('./user').User;
var Conversation = require('./conversation').Conversation;
var Event = require('./events/event').Event;

// Conversation Client Error
var ConversationClientError = require('./conversationClientError');

var NexmoApiError = ConversationClientError.NexmoApiError;
// var NexmoClientError = ConversationClientError.NexmoClientError;

/**
 * Core application class for the SDK.
 * Application is the parent object holding the list of conversations, the session object.
 * Provides methods to create conversations and retrieve a list of the user's conversations, while it holds the listeners for 
 * user's invitations 
 * @class
 * @param {ConversationClient} SDK session object
 * @param {Object} params
 * @example <caption>Accessing conversations' list</caption>
 * 
 * rtc.login(token).then(
 *  function(application){
 * //get a list of conversations the logged in user has been invited to or has joined
 *      console.log(application.conversations);
 * //get the user's name and id
 *      console.lof(application.me.name, application.me.id)
 *   });
 */
var Application = function(session, params) {
	this.log = logger.getLogger("Application");
	this.session = session;
	this.conversations = {};
	this.synced_conversations_count = 0;
	this.start_sync_time = 0;
	this.stop_sync_time = 0;

	this.me = null;
	// Map the params
	for (var key in params) {
		this[key] = params[key];
	}
};

Application.prototype = new WildEmitter();
//reset the original Type
Application.prototype.constructor = Application;

/**
 * Application listening for invites.
 *
 * @event Application#member:invited
 * 
 * @property {Member} member - The invited member
 * @property {Event} event - The invitation event
 * 
 * @example <caption>listen for your invites</caption>
 * application.on("member:invited",
 *   function(member, event) {
 *      console.log("Invited to the conversation: " + event.conversation.display_name || event.conversation.name);  
 * 
 * //identify the sender.
 * console.log("Invited by: " + member.invited_by);
 * 
 * //accept an invitation.
 *  application.conversations[event.conversation.id].join();
 * 
 * //decline the invitation.
 application.conversations[event.conversation.id].leave(); 
 */
/**
 * Application listening for joins.
 *
 * @event Application#member:joined
 * 
 * @property {Member} member - the member that joined the conversation
 * @property {Event} event -  the join event
 * 
 * @example <caption>listen join events in Application level</caption>
 *  application.on("member:joined",
 *      function(member, event) {
 *              console.log("JOINED", "Joined conversation: " + event.conversation.display_name || event.conversation.name);
 *              });
 *      });
 */

Application.prototype._handleEvent = function(event) {
	var self = this;
	var cid = event.cid;
	if (cid in self.conversations) {
		self.conversations[cid]._handleEvent(event);
	} else {
		//get the conversation you don't know about (case: joined by another user)
		self.getConversation(cid).then(function(conversation) {
			self.conversations[cid] = conversation;
			self.emit(event.type, conversation.members[event.from], new Event(conversation, event));
		});
	}
};

/**
 * Query the service to create a new conversation
 * The conversation name must be unique per application.
 * @param {Object} [params] - leave empty to get a GUID as name
 * @param {String} params.name - the name of the conversation. A UID will be assigned if this is skipped
 * @param {String} params.display_name - the display_name of the conversation.
 * @returns {Promise<Conversation>} - the created Conversation
 * @example <caption>Create a conversation and join</caption>
 * application.newConversation().then(
 *     function(conversation) {
 * 
 *         //join the created conversation
 *         conversation.join().then(
 *             //Get the user's member belonging in this conversation.
 *             //You can also access it via conversation.me
 *             function(member) {
 *                 console.log("Joined as " + member.user.name);
 *             });
 * 
 *     }).catch(function(error) {
 *     console.log(error);
 * });
 */
Application.prototype.newConversation = function(params) {
	var self = this;
	var p = new Promise(function(resolve, reject) {
		self.session.sendRequest({
			type: 'new:conversation',
			body: params
		}, function(response) {
			if (response.type === 'new:conversation:success') {
				var conv = new Conversation(self, response.body);
				self.conversations[conv.id] = conv;
				// do a get conversation to get the whole model as shaped in the service, 
				self.getConversation(conv.id).then(function(conversation) {
					resolve(conversation);
				});
			} else {
				reject(new NexmoApiError(response));
			}
		});
	});
	return p;
};

/**
 * Query the service to create a new conversation and join it
 * The conversation name must be unique per application.
 * @param {Object} [params] - leave empty to get a GUID as name
 * @param {String} params.name - the name of the conversation. A UID will be assigned if this is skipped
 * @param {String} params.display_name - the display_name of the conversation.
 * @returns {Promise<Conversation>} - the created Conversation
 * @example <caption>Create a conversation and join</caption>
 * application.newConversationAndJoin().then(
 *     function(conversation) {
 * 
 *         //join the created conversation
 *         conversation.join().then(
 *             //Get the user's member belonging in this conversation.
 *             //You can also access it via conversation.me
 *             function(member) {
 *                 console.log("Joined as " + member.user.name);
 *             });
 * 
 *     }).catch(function(error) {
 *     console.log(error);
 * });
 */
Application.prototype.newConversationAndJoin = function(params) {
	var self = this;
	return self.newConversation(params).then(function(conversation) {
		return conversation.join().then(function() {
			return conversation;
		});
	});

};
/**
 * Query the service to obtain a complete list of conversations of which the
 * logged-in user is a member with a state of `JOINED` or `INVITED`. 
 * 
 * @returns {Promise<Object<Conversation>>} - Populate Application.conversations.
 */
Application.prototype.getConversations = function(params) {
	var self = this;
	var p = new Promise(function(resolve, reject) {
		self.session.sendRequest({
			type: 'user:conversations',
			body: params
		}, function(response) {
			if (response.type === 'user:conversations:success') {
				// Iterate and create the conversations if not existent
				// (note that cache WebWorker also populates conv list)
				// These are just templates without the full member information
				// conversations:
				response.body.map(function(c) {
					var conv = new Conversation(self, c);
					if (self.conversations[conv.id] === undefined) {
						self.conversations[conv.id] = conv;
					}
				});
				self.syncConversations(response.body);
				resolve(self.conversations);
			} else {
				reject(new NexmoApiError(response));
			}
		});
	});
	return p;
};

/**
 * Application listening sync status.
 *
 * @event Application#sync:progress
 * 
 * @property {Number} status.sync_progress - Percentage of fetched conversations
 * @property {Number} status.idb_progress - Percentage of conversations stored in indexedDB
 * @example <caption>listening for changes in the synchronisation progress</caption>
 *  application.on("sync:progress",
 *      function(status) {
 *			console.log(data.sync_progress);
 *          console.log(data.idb_progress);
 *       });
 *  });
 */
Application.prototype.syncConversations = function(conversations) {
	var self = this;
	var conversations_length = conversations.length;

	var d = new Date();
	self.start_sync_time = (window && window.performance) ? window.performance.now() : d.getTime();

	var fetchConversationForStorage = function() {
		self.synced_conversations_percentage = ((self.synced_conversations_count / conversations_length) * 100).toFixed(2);

		var status_payload = {
			sync_progress: self.synced_conversations_percentage
		};
		if (self.session.cache) {
			self.idb_conversations_percentage = ((self.session.cache.conversations_idb_count / conversations_length) * 100).toFixed(2);
			status_payload.idb_progress = self.idb_conversations_percentage
		}
		self.emit('sync:progress', status_payload);

		self.log.debug('Loading sync progress: ' + self.synced_conversations_count + '/' +
			conversations_length + ' - ' + self.synced_conversations_percentage + '%');
		self.log.debug('Loading idb progress: ' + self.session.cache.conversations_idb_count + '/' +
			conversations_length + ' - ' + self.idb_conversations_percentage + '%');

		if (self.synced_conversations_percentage >= 100) {
			var d = new Date();
			self.stop_sync_time = (window && window.performance) ? window.performance.now() : d.getTime();
			self.log.info('Loaded conversations in ' + (self.stop_sync_time - self.start_sync_time) + 'ms');
		}

		if (self.synced_conversations_count < conversations_length) {
			self.getConversation(conversations[self.synced_conversations_count].id).then(function() {
				fetchConversationForStorage();
			});
			self.synced_conversations_count++;
			self.sync_progress_buffer++;
		}
	};
	fetchConversationForStorage();

}

/**
 * Query the service to see if this conversation exists with the
 * logged in user as a member and retrieve the data object
 * Result added (or updated) in this.conversations
 * 
 * @param {String} id - the id of the conversation to fetch  
 * @returns {Promise<Conversation>} - the requested conversation 
 */
Application.prototype.getConversation = function(id) {
	var self = this;
	var p = new Promise(function(resolve, reject) {
		self.session.sendRequest({
			type: 'conversation:get',
			cid: id,
			body: {}
		}, function(response) {
			if (response.type === 'conversation:get:success') {
				var updateOrCreateConversation = function() {
					if (self.conversations[response.body.id]) {
						self.conversations[response.body.id].updateObjectInstance(self, response.body);
						return self.conversations[response.body.id];
					}
					return new Conversation(self, response.body);
				};
				//check if the response is from cache already formed as Conversation object, reuse it
				var conv = (response.body instanceof Conversation) ?
					response.body : updateOrCreateConversation();


				self.conversations[conv.id] = conv;
				// Populate the events
				conv.getEvents().then(function(events) {
					// Complete
					conv.events = events;
					resolve(conv);
					//update cached conversation to maintain proper event objects
					//TODO move this in cache module
					if (self.session.cache)
						self.session.cache.update_conversation(conv);
				});
			} else {
				reject(new NexmoApiError(response));
			}
		});
	});
	return p;
};

/**
 * Get Details of a user
 * @param {String} [id] - the id of the user to fetch, if skipped, it returns your own user details
 * @returns {Promise<User>} 
 */
Application.prototype.getUser = function(user_id) {
	user_id = user_id || this.me.id;
	var self = this;
	var p = new Promise(function(resolve, reject) {
		var params = {
			user_id: user_id
		};
		self.session.sendRequest({
			type: 'user:get',
			from: self.me.id,
			body: params
		}, function(response) {
			if (response.type === 'user:get:success') {
				resolve(new User(self, response.body));
			} else {
				reject(new NexmoApiError(response));
			}
		});
	});
	return p;
};


module.exports = {
	Application: Application
};