//workaround to keep the web worker in the same file
//we create the worker's code
//we convert it to a blob object and pass it to the worker constructor through the createObjectURL

Cache_worker = function() {
	var worker = {
		get function() {
			return function() {
				var IDBTransaction = self.IDBTransaction || self.webkitIDBTransaction;

				if (IDBTransaction) {
					IDBTransaction.READ_WRITE = IDBTransaction.READ_WRITE || 'readwrite';
					IDBTransaction.READ_ONLY = IDBTransaction.READ_ONLY || 'readonly';
				}

				/***
				 * Create database
				 * */
				var request = indexedDB.open('ConversationClient', 1);
				var dbReady = false;
				var pendingMessages = [];

				request.onupgradeneeded = function(e) {
					// e is an instance of IDBVersionChangeEvent
					var idb = e.target.result;

					//conversations store
					if (idb.objectStoreNames.contains('conversations')) {
						idb.deleteObjectStore('conversations');
					}

					var store = idb.createObjectStore('conversations', {
						keyPath: 'cid'
					});
					// createIndex operations possible to be pefromed on store.createIndex
					// store.createIndex('by_cid', 'cid', { unique: true });

					//conversation list store

					if (idb.objectStoreNames.contains('conversations_list')) {
						idb.deleteObjectStore('conversations_list');
					}

					var store_list = idb.createObjectStore('conversations_list', {
						keyPath: 'name'
					});
					// createIndex operations possible to be pefromed on store.createIndex
					// store_list.createIndex('by_name', 'name', { unique: true });


				};

				request.onsuccess = function() { /* add, update, delete, ... */
					dbReady = true;
					pendingMessages.forEach(function(e) {
						onmessage(e);
					});
					self.postMessage({
						worker_action: 'db:initialised'
					});
				};
				request.onblocked = function() {
					console.log('DB open blocked', e);
				};
				request.onerror = function() { /* handle error */
					console.log(e, 'error in DB', e);
				};
				request.onabort = function() { /* handle error */
					console.log(e, 'transaction will automatically abort due the failed request', e);
				};
				request.oncomplete = function() {
					// All requests have succeeded and the transaction has committed.
					console.log('oncomplete', e);
				};
				//worker events
				onmessageerror = function(error) {
					console.log('on message error invoked', error);
				};
				onmessage = function(e) {
					var tx;
					var eventStore;

					if (!dbReady) {
						console.log('adding pending request');
						pendingMessages.push(e);
						return;
					}
					console.log('processing event: ', e.data);

					if (request) {
						switch (e.data.worker_action) {
							case 'conversations:invalidate':
								request = indexedDB.deleteDatabase('ConversationClient');
								// .onsuccess = function(event) {
								// 	self.postMessage({
								// 		worker_action: 'conversations:invalidate',
								// 		result: event
								// 	});
								// 	console.log("Database deleted successfully");
								close();
								// 	console.log('closing down the worker');
								// 	console.log(event.result); // should be undefined
								// };
								self.postMessage({
									worker_action: 'conversations:invalidate:success',
								});
								break;
							case 'conversation:storage:add':
								tx = request.result.transaction('conversations', IDBTransaction.READ_WRITE);
								eventStore = tx.objectStore('conversations');
								eventStore.put({
									cid: e.data.body.id,
									conversation: e.data
								}).onsuccess = function(event) {
									console.log('conversations updated');
									var countRequest = eventStore.count();
									countRequest.onsuccess = function() {
										self.postMessage({
											worker_action: 'conversations:idb:count',
											conversations_idb_count: countRequest.result
										});
									};
								};
								break;
							case 'user:conversations:storage:add':
								tx = request.result.transaction('conversations_list', IDBTransaction.READ_WRITE);
								eventStore = tx.objectStore('conversations_list');
								eventStore.put({
									name: 'username',
									data: e.data
								}).onsuccess = function(event) {};
								break;
							case 'user:conversations:storage:get':
								tx = request.result.transaction('conversations_list', IDBTransaction.READ_ONLY);
								eventStore = tx.objectStore('conversations_list');
								eventStore.getAll().onsuccess = function(event) {
									if (!event.target.result) return;
									event.target.result.worker_action = e.data.worker_action;
									self.postMessage(event.target.result);
								};
								break;
								//TODO
								//make it smarter to identify when a worker has not finish its work before the next event
								//provide an event e.g. onComplete from a worker's task
							case 'conversation:storage:delete':
								tx = request.result.transaction('conversations', IDBTransaction.READ_WRITE);
								eventStore = tx.objectStore('conversations');
								eventStore.delete(e.data.cid).onsuccess = function(event) {
									console.log('conversation deleted');
								};
								break;
							case 'events:storage:updateEvents':
								tx = request.result.transaction('conversations', IDBTransaction.READ_WRITE);
								eventStore = tx.objectStore('conversations');
								eventStore.get(e.data.cid).onsuccess = function(event) {
									if (!event.target.result) return;
									event.target.result.conversation.body.events = e.data;
									var putCommand = eventStore.put(event.target.result);
									putCommand.onsuccess = function(event) {
										//console.log('event updated');
									};
									putCommand.onerror = function(event) {
										//console.log(event);
									};
								};
								break;
							case 'events:storage:add':
								tx = request.result.transaction('conversations', IDBTransaction.READ_WRITE);
								eventStore = tx.objectStore('conversations');
								eventStore.get(e.data.cid).onsuccess = function(event) {
									if (!event.target.result || !event.target.result.conversation.body.events) return;
									event.target.result.conversation.body.events.body[e.data.id] = e.data;
									var putCommand = eventStore.put(event.target.result).onsuccess = function(event) {
										console.log('conversations updated');
									};
								};
								break;
							case 'events:storage:get':
								tx = request.result.transaction('conversations', IDBTransaction.READ_ONLY);
								eventStore = tx.objectStore('conversations');
								eventStore.get(e.data.cid).onsuccess = function(event) {
									if (!event.target.result) return;
									event.target.result.worker_action = e.data.worker_action;
									self.postMessage(event.target.result.conversations);
								};
								break;
							case 'events:storage:getAll':
								tx = request.result.transaction('conversations', IDBTransaction.READ_ONLY);
								eventStore = tx.objectStore('conversations');
								eventStore.getAll().onsuccess = function(event) {
									if (!event.target.result) return;
									event.target.result.worker_action = e.data.worker_action;
									self.postMessage(event.target.result);
								};
								break;
						}
					}
				};
			};
		}
	};

	if (typeof Blob !== 'undefined') {
		var code = worker.function.toString();
		code = code.substring(code.indexOf('{') + 1, code.lastIndexOf('}'));
		var cache_worker_blob = new Blob([code], {
			type: 'application/javascript'
		});
		this.cache_worker_blob = cache_worker_blob;
	}
};
module.exports = Cache_worker;