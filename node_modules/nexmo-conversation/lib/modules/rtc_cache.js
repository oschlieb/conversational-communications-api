var Cache_worker = require('./cache-worker.js');
var logger = require('loglevel');


var RTC_Cache = function(rtc) {
	var self = this;
	this.log = logger.getLogger("Cache");

	var cache_worker = new Cache_worker();

	this.worker = null;
	this.conversation_data = [];

	//load token from cache
	var NXMO_user_data = null;
	if (typeof(Storage) !== 'undefined') {
		NXMO_user_data = localStorage.getItem('NXMO_user_data');
		if (NXMO_user_data) {
			self.user_data = JSON.parse(NXMO_user_data);
		}
	}
	if (typeof window !== 'undefined' && !!window.Worker) {
		this.log.info('initialising cache webWorker');
		this.worker = new Worker(URL.createObjectURL(cache_worker.cache_worker_blob));

		this.worker.onmessage = function(event) {
			self.log.debug('[<--] (WebWorker): ', (event.data.worker_action));
			switch (event.data.worker_action) {
				case 'user:conversations:storage:get':
					self.conversations_cached = event.data;
					break;
				case 'events:storage:getAll':
					event.data.forEach(function(event) {
						self.conversation_data[event.cid] = event.conversation;
						self.conversation_data[event.cid].fromStorage = true;
					});
					break;
				case 'conversations:idb:count':
					self.conversations_idb_count = event.data.conversations_idb_count;
					break;
			}
			delete event.data.worker_action;
		};
	} else {
		this.log.warn('webWorker is not supported');
		return;
	}
	this.rtc = rtc;
	this.conversations_idb_count = 0;
};

RTC_Cache.prototype.init = function(rtc) {
	if (!this.worker) return;
	var self = this;
	rtc.connection.io.on('packet', function(packet) {
		if (!rtc.cache || packet.type !== 2 || packet.data[0] === 'echo') return;
		var response = packet.data[1];
		// Set the type of the response		
		response.type = packet.data[0];
		self.log.debug("[<--]", response.type, JSON.stringify(response));
		//use the cache object to determine if it's intended to be cached and cache it
		rtc.cache.add_response(response);
	});

	rtc.connection.io.on('reconnect', function() {
		if (self.user_data) {
			rtc.login(rtc.cache.user_data.token);
		}
	});

	self._sendRequest = rtc.sendRequest;
	rtc.sendRequest = function(request, callback) {
		var type = request.type;
		self.process_cache(type, request, callback, this).then(
			function(processed_response) {
				if (processed_response) {
					return callback(processed_response);
				} else {
					return self._sendRequest.call(self.rtc, request, callback);
				}
			});
	}
};
//generic request/response lazy caching
RTC_Cache.prototype.add_response = function(response) {
	if (!this.worker) return;
	var self = this;

	if (response.type === 'session:success') {
		//fetch the conversations list is expected right after the login
		self.worker.postMessage({
			worker_action: 'user:conversations:storage:get'
		});
	}
	if (this.conversation_data[response.cid]) {
		//we already have cached this conversation,
		//check if we got the events for it and create the events object
		if (response.type === 'conversation:events:success' && (this.conversation_data[response.cid] &&
				!this.conversation_data[response.cid].events)) {
			this.conversation_data[response.cid].events = response.body;
			if (this.worker) {
				response.worker_action = 'events:storage:updateEvents';
				this.worker.postMessage(response);
				this.log.debug('[-->] (WebWorker): ', JSON.stringify(response));
			}
		}
	}
	switch (response.type) {
		case 'conversation:get:success':
			//prepare conversation cache/storage item
			this.setConversationDirty(response.body.id, false);
			this.conversation_data[response.body.id] = response.body;
			if (this.worker) {
				response.worker_action = 'conversation:storage:add';
				this.worker.postMessage(response);
				this.log.debug('[-->] (WebWorker): ', JSON.stringify(response.body));
			}

			break;
		case 'user:conversations:success':
			//don't fetch here all the conversations
			self.conversations_cached = response;
			if (this.worker) {
				response.worker_action = 'user:conversations:storage:add';
				this.worker.postMessage(response);
				this.log.debug('[-->] (WebWorker): ', JSON.stringify(response));
			}
			break;
		default:
	}
};

RTC_Cache.prototype.update_conversation = function(conversation) {
	if (!this.worker) return;
	this.conversation_data[conversation.id] = conversation;
};

RTC_Cache.prototype.addConversationEvent = function(cid, message, sequence_number, event) {
	if (!this.worker) return;
	//message param has a value for events: text, image

	//******
	//now the message can have event from a member status : member:join 
	// we need to allow the event to be added with the flow below, but also trigger a way to filter events and specific actions for them 
	// e.g. an event:delete should also trigger a new command for the worker to go to the conversation[id] 
	// and find the event.id and empty the context + add the deleted timestamp --> same actions as when we receive here the delete:event
	// similarly another action needs to be triggered to add a member (and update a member object) 
	// FAILED ATTEMPT: [because of circular link in objects we cannot pass them to the worker]
	// based on the conversation.js:529 we will receive a member:joined event, this will update the conversation list in the runtime and will 
	// create the message to be passed in the worker, the message each time contains the object to update, so we won't need to re-do the work in the worker 
	//and process again the events.

	if (message && this.conversation_data[cid]) {

		if (!this.conversation_data[cid].events) {
			//in case we are between the empty conversation object and the second that includes the events we need to make the events array
			this.conversation_data[cid].events = [];
		}
		this.conversation_data[cid].events[message.id] = message;
		this.conversation_data[cid].sequence_number = sequence_number;
		event.worker_action = 'events:storage:add';
		// event.worker_action = "conversation:storage:add";
		// var simplified_conversation_data = {
		// 	cid: cid,
		// 	events: this.conversation_data[cid].events,
		// 	members: this.conversation_data[cid].members,
		// }
		this.worker.postMessage(event);
		this.log.debug('[-->] (WebWorker): ', JSON.stringify(event.worker_action));

	}
	//we can handle actions for the rest of the events here
};

RTC_Cache.prototype.process_cache = function(type, request, callback) {
	var self = this;
	//keep all the data to reply on reconnect
	var p = new Promise(function(resolve, reject) {
		if (type === 'session:success') {
			/// TODO Control when thishappens and move it to login
			worker.postMessage({
				worker_action: 'events:storage:getAll'
			});
			self.log.debug('[-->] (WebWorker): ', 'worker_action:events:storage:getAll');
		}
		//skip cache if conversation is dirty
		//TODO remove the "per-event" logic from here and find a more generic way to handle this
		if (type === 'user:conversations') {
			if (self.conversations_cached && self.conversations_cached.body) {
				self.conversations_cached.type = 'user:conversations:success'; //hack it to be processed
				resolve(self.conversations_cached);
				self.log.debug('[-->|<--] conversation list');
			} else {
				resolve(false);
			}
		}
		if ((self.conversation_data[request.cid] &&
				self.conversation_data[request.cid].isDirty)) {
			resolve(false);

		} else {
			if ((self.conversation_data[request.cid] &&
					((type === 'conversation:events' && (self.conversation_data[request.cid].events)) ||
						(type === 'conversation:get') && self.conversation_data[request.cid]))) {

				if (type === 'conversation:get' && !request.fromCache) {
					resolve({
						cid: request.cid,
						body: (!self.conversation_data[request.cid].fromStorage) ?
							self.conversation_data[request.cid] : self.conversation_data[request.cid].body,
						type: 'conversation:get:success'
					});
				} else if (type === 'conversation:events' || self.conversation_data[request.cid].events ||
					(self.conversation_data[request.cid].fromStorage && self.conversation_data[request.cid].body.events)) {
					resolve({
						fromCache: !self.conversation_data[request.cid].fromStorage,
						cid: request.cid,
						body: (!self.conversation_data[request.cid].fromStorage) ?
							self.conversation_data[request.cid].events : self.conversation_data[request.cid].body.events.body,
						type: 'conversation:events:success'
					});
				}
				self.log.debug('[-->|<--] ', type, JSON.stringify(self.conversation_data[request.cid].id || self.conversation_data[request.cid].cid));
				//TODO: Detect if this happened in offline mode, so we will need to mark as dirty
			} else {
				resolve(false);
			}
		}
	});
	return p;
};

RTC_Cache.prototype.setConversationDirty = function(conversation_id, value) {
	var self = this;
	if (self.conversation_data[conversation_id]) {
		self.conversation_data[conversation_id].isDirty = value;
		if (self.worker && value) {
			var event = {
				cid: conversation_id,
				worker_action: 'conversation:storage:delete'
			};
			self.worker.postMessage(event);
			self.log.debug('[-->] (WebWorker): ', JSON.stringify(event.worker_action));
		}
		//when setting a conversation to dirty, we need to remove it from persistent storage
	}
};

RTC_Cache.prototype.getConversationDirtyStatus = function(conversation_id) {
	if (this.conversation_data[conversation_id])
		return this.conversation_data[conversation_id].isDirty;
};

RTC_Cache.prototype.updateToken = function(user_data) {
	if (typeof(Storage) !== 'undefined') {
		localStorage.setItem('NXMO_user_data', JSON.stringify(user_data));
	}
};

RTC_Cache.prototype.invalidate = function() {
	if (!this.worker) return;
	var event = {
		worker_action: 'conversations:invalidate'
	};
	if (typeof(Storage) !== 'undefined') {
		localStorage.removeItem('NXMO_user_data');
	}
	this.worker.postMessage(event);
	this.log.debug('[-->] (WebWorker): ', JSON.stringify(event.worker_action));
};

module.exports = RTC_Cache;