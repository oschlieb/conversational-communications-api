/*
 * SDK file Test
 *
 * Copyright (c) Nexmo Inc. 2017
 */

var chai = require('chai');
var chaiAsPromised = require("chai-as-promised");
var sinon = require('sinon');
var sinonChai = require("sinon-chai");

var expect = chai.expect;

chai.use(chaiAsPromised);
chai.use(sinonChai);

var ConversationClient = require('../../lib/sdk');

describe('ConversationClient', function() {
	var sandbox;

	beforeEach(function() {
		sandbox = sinon.sandbox.create();
	});
	afterEach(function() {
		sandbox.restore();
	});
	describe('Object', function() {
		describe('Properties', function() {

			it('should initialize with default config values', function() {
				var config_default_values = {
					url: '@@ws_url',
					path: '/rtc',
					debug: false,
					reconnection: true,
					forceNew: true,
					autoConnect: true,
					cache: true,
					ips_url: '@@ips_url',
					environment: '@@environment',
					SDK_version: '@@SDK_version',
					bugsnag_key: 'cd2dcd56892c3cd260b12caf6eecf022',
					repository: '@@repository',
					iceServers: {
						urls: 'stun:stun.l.google.com:19302'
					}
				}
				var conversationClient = new ConversationClient();
				return Promise.all([
					expect(conversationClient.config).to.deep.include(config_default_values),
					expect(conversationClient.sessionReady).to.be.false
				])
			});

			it('should set config params on new ConversationClient(params)', function() {
				var config_values = {
					url: 'other_url',
					path: 'other_path',
					debug: true,
					reconnection: false,
					forceNew: false,
					autoConnect: false,
					cache: false,
					ips_url: 'other_ips_url',
					environment: 'other_env',
					SDK_version: 'other_version',
					bugsnag_key: 'other_key',
					repository: 'other_repo',
					iceServers: {
						urls: 'other_url'
					}
				}
				var conversationClient = new ConversationClient(config_values);
				return expect(conversationClient.config).to.deep.include(config_values)
			});
			describe('conversationClient.log', function() {

				it('should be able to init logs in silent', function() {
					var conversationClient = new ConversationClient({
						debug: false
					});
					return expect(conversationClient.log.getLevel()).to.equal(5);
				});

				it('should be able to init logs to debug', function() {
					var conversationClient = new ConversationClient({
						debug: true
					});
					return expect(conversationClient.log.getLevel()).to.equal(1);
				});

				it('should be able to set logs to debug', function() {
					var conversationClient = new ConversationClient({
						debug: true
					});
					conversationClient.log.setLevel('silent');
					return expect(conversationClient.log.getLevel()).to.equal(5);
				});
			});
		});
	});

	describe('Function', function() {
		describe('login()', function() {
			it('should accept and pass a token to login', function() {
				var conversationClient = new ConversationClient();
				conversationClient.sendRequest = function(params, callback) {
					var response = {
						type: 'error:session:login',
						body: {}
					}
					callback(response);
				};
				var conversationClientSpy = sandbox.spy(conversationClient, 'sendRequest');
				var token = 'fake token';
				var loginPromise = conversationClient.login(token);
				return Promise.all([
					expect(conversationClientSpy).to.have.been.calledWithMatch({
						type: 'session:login',
						body: {
							token: token
						}
					}),
					expect(loginPromise).to.be.rejected
				]);
			});
			it('should reject with NexmoApiError', function() {
				var conversationClient = new ConversationClient();
				conversationClient.sendRequest = function(params, callback) {
					var response = {
						type: 'error:session:login',
						body: {}
					}
					callback(response);
				};
				var loginPromise = conversationClient.login();
				return expect(loginPromise).to.be.rejectedWith('error:session:login');
			});
		});

		describe('logout()', function() {
			it('should call sendRequest with type session:logout', function() {
				var conversationClient = new ConversationClient();
				conversationClient.sendRequest = function(params, callback) {
					var response = {
						type: 'session:logged-out',
						body: {}
					}
					callback(response);
				};
				var spy_logout = sandbox.spy(conversationClient, 'sendRequest');
				conversationClient.logout();
				return expect(spy_logout).to.have.been.calledWithMatch({
					type: 'session:logout'
				});
			});

			it('should fullfil with type error:logout and call disconnect', function() {
				var conversationClient = new ConversationClient();
				var response = {
					type: 'session:logged-out',
					body: {}
				}
				conversationClient.sendRequest = function(params, callback) {
					callback(response);
				};
				var disconnectSpy = sandbox.spy(conversationClient, 'disconnect');
				var cacheSpy = sandbox.spy(conversationClient.cache, 'invalidate');
				var logoutPromise = conversationClient.logout();
				return Promise.all([
					expect(logoutPromise).to.be.fulfilled.then(function(resp) {
						return expect(resp.type).to.equal('session:logged-out')
					}),
					expect(disconnectSpy).to.have.been.called,
					expect(cacheSpy).to.have.been.called
				]);
			});

			it('should reject the promise on log-out error', function() {
				var conversationClient = new ConversationClient();
				var response = {
					type: 'error:session:logout',
					body: {}
				}
				conversationClient.sendRequest = function(params, callback) {
					callback(response);
				};
				var logoutPromise = conversationClient.logout();
				return expect(logoutPromise).to.be.rejectedWith('error:session:logout');
			});

			it('should call media.disable if a stream is active', function() {
				var conversationClient = new ConversationClient();
				conversationClient.sendRequest = function(params, callback) {
					var response = {
						type: 'session:logged-out',
						body: {}
					}
					callback(response);
				};
				var application = {
					activeStream: {
						conversation: {
							media: {
								disable: function() {
									return Promise.resolve();
								}
							}
						},
						stream: {},
						rtc_id: 'rtcid'
					}
				};
				conversationClient.application = application;

				var spy_disableAudio = sandbox.spy(application.activeStream.conversation.media, 'disable');
				conversationClient.logout();
				return expect(spy_disableAudio).to.have.been.called;
			});

			it('should logout on successful audio terminate (chain promise)', function() {
				var conversationClient = new ConversationClient();

				var application = {
					activeStream: {
						conversation: {
							media: {
								disable: function() {
									return Promise.resolve();
								}
							}
						},
						stream: {},
						rtc_id: 'rtcid'
					}
				};
				conversationClient.application = application
				conversationClient.sendRequest = function(params, callback) {
					var response = {
						type: 'session:logged-out',
						body: {}
					}
					callback(response);
				};

				var spy_logout = conversationClient.logout();
				return expect(spy_logout).to.be.fulfilled;
			});

			it('should logout on unsuccessful audio terminate (chain promise)', function() {
				var conversationClient = new ConversationClient();

				var application = {
					activeStream: {
						conversation: {
							media: {
								disable: function() {
									return Promise.reject();
								}
							}
						},
						stream: {},
						rtc_id: 'rtcid'
					}
				};
				conversationClient.application = application
				conversationClient.sendRequest = function(params, callback) {
					var response = {
						type: 'session:logged-out',
						body: {}
					}
					callback(response);
				};

				var spy_logout = conversationClient.logout();
				return expect(spy_logout).to.be.fulfilled;
			});
		});

		describe('sendRequest()', function() {
			it('should generate a request.tid');
			it('should not try to send a request if the connection is not active');
			it('should trigger the callback if the event is cached');
			it('should emit the event to the connection');
			it('should persist the request');
		});

		describe('disconnect()', function() {
			it('should trigger the connection.disconnect()');
		});
		describe('connect()', function() {
			it('should trigger the connection.connect()');
		});
	});

	describe('Events', function() {
		var conversationClient;

		beforeEach(function() {
			conversationClient = new ConversationClient();
		});

		it('should emit "ready" event and set sessionReady on connection "connect"', function() {
			var emitSpy = sandbox.spy(conversationClient, 'emit');
			conversationClient.connection.emit('connect');
			return Promise.all([
				expect(emitSpy).to.have.been.calledWithExactly('ready'),
				expect(conversationClient.sessionReady).to.be.true
			]);
		});

		it('should emit "connecting" event on connection "connecting"', function() {
			var emitSpy = sandbox.spy(conversationClient, 'emit');
			conversationClient.connection.emit('connecting');
			return expect(emitSpy).to.have.been.calledWithExactly('connecting');
		});

		it('should emit "disconnect" event on connection "disconnect"', function() {
			var emitSpy = sandbox.spy(conversationClient, 'emit');
			conversationClient.connection.emit('disconnect');
			return expect(emitSpy).to.have.been.calledWithExactly('disconnect');
		});

		it('should emit "reconnect" event on connection "reconnect"', function() {
			var retry_number = 4;
			var emitSpy = sandbox.spy(conversationClient, 'emit');
			conversationClient.connection.emit('reconnect', retry_number);
			return expect(emitSpy).to.have.been.calledWithExactly('reconnect', retry_number);
		});

		it('should emit "reconnecting" event on connection "reconnecting"', function() {
			var retry_number = 4;
			var emitSpy = sandbox.spy(conversationClient, 'emit');
			conversationClient.connection.emit('reconnecting', retry_number);
			return expect(emitSpy).to.have.been.calledWithExactly('reconnecting', retry_number);
		});

		it('should try to relogin on connection "reconnect" if the token is persisted', function() {
			var fake_token_value = 0;
			conversationClient.cache = {
				user_data: {
					token: fake_token_value
				}
			};
			var loginStub = sandbox.stub(conversationClient, 'login');
			conversationClient.connection.emit('reconnect', 0);
			expect(loginStub).to.have.been.calledWithExactly(fake_token_value);
		});

		it('should log an error on socket connection error', function() {
			var logSpy = sandbox.spy(conversationClient.log, 'error');
			conversationClient.connection.emit('error', 'error message')
			expect(logSpy).to.have.been.calledWith("Socket.io reported a generic error", 'error message');
		});

		it('should emit "error" event on connection "error"', function() {
			var errorMessage = 'erroer message';
			var emitSpy = sandbox.spy(conversationClient, 'emit');
			conversationClient.connection.emit('error', errorMessage);
			return expect(emitSpy).to.have.been.calledWith('error');
		});

		describe('packet event', function() {
			it('should ignore type 2 (incomplete packets) events');
			it('should ignore echo events');
			it('should handle the callbacks for expected responses');
			//in cases of events that are not triggered as a response to our actions (e.g. media events)
			it('should handle application wide incoming events (unexpected)');
		});

	});
});