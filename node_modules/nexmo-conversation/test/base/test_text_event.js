/*
 * Conversation Client Text Event Test
 *
 * Copyright (c) Nexmo Inc. 2017
 */

var chai = require('chai');
var chaiAsPromised = require('chai-as-promised');
var sinon = require('sinon');
var sinonChai = require('sinon-chai');

var assert = chai.assert;
var expect = chai.expect;

chai.use(chaiAsPromised);
chai.use(sinonChai);
var Conversation = require('../../lib/conversation').Conversation;
var TextEvent = require('../../lib/events/text_event').TextEvent;

describe('TextEvent', function() {
	describe('Function', function() {
		describe('del()', function() {
			var textEvent;
			var application;
			var spy_sendRequest;
			var event_id = 1;
			beforeEach(function() {
				application = {
					me: {
						id: 'my user id'
					},
					session: {
						log: {
							debug: function() {}
						},
						sendRequest: function(params, callback) {
							callback({
								type: 'event:delete:success'
							});
						}
					}
				};
				var conversation = new Conversation(application);
				conversation.id = 'cid';
				conversation.me = {
					id: 'some_id'
				}
				spy_sendRequest = sinon.spy(conversation.application.session, 'sendRequest');
				textEvent = new TextEvent(conversation, {
					id: event_id
				})
			});

			it('should resolve the promise', function() {

				var promise_del = textEvent.del();
				return expect(promise_del).to.be.fulfilled;
			});

			it('should delete this event', function() {
				textEvent.del();
				return expect(spy_sendRequest).to.have.been.calledWith({
					type: 'event:delete',
					cid: textEvent.conversation.id,
					from: textEvent.conversation.me.id,
					body: {
						"event_id": event_id
					}
				});
			});

			it('should reject with API error', function() {
				var response = {
					type: 'error:event:delete'
				}; //override the stubbed sendRequest for error
				application.session.sendRequest = function(params, callback) {
					callback({
						type: response.type
					});
				}
				var conversation = new Conversation(application);
				conversation.me = {
					id: 'some_id'
				}
				textEvent = new TextEvent(conversation, null)
				var promise_del = textEvent.del();
				return expect(promise_del).to.be.rejectedWith(response.type).then(function(error) {
					return Promise.all([
						expect(error).to.include.all.keys('stack', 'message', 'name'),
						expect(error.message).to.equal('type: ' + response.type + ', description: ')
					]);
				});
			});
		});

		describe('seen()', function() {
			var textEvent;
			var application;
			var spy_sendRequest;
			var event_id = 1;
			beforeEach(function() {
				application = {
					me: {
						id: 'my user id'
					},
					session: {
						log: {
							debug: function() {}
						},
						sendRequest: function(params, callback) {
							callback({
								type: 'text:seen:success'
							});
						}
					}
				};
				var conversation = new Conversation(application);
				conversation.id = 'cid';
				conversation.me = {
					id: 'some_id'
				}
				spy_sendRequest = sinon.spy(conversation.application.session, 'sendRequest');
				textEvent = new TextEvent(conversation, {
					id: event_id
				})
			});

			it('should resolve the promise', function() {

				var promise_seen = textEvent.seen();
				return expect(promise_seen).to.be.fulfilled;
			});

			it('should send seen for this event', function() {
				textEvent.seen();
				return expect(spy_sendRequest).to.have.been.calledWith({
					type: 'text:seen',
					cid: textEvent.conversation.id,
					from: textEvent.conversation.me.id,
					body: {
						"event_id": event_id
					}
				});
			});

			it('should reject to send seen for own event', function() {
				textEvent.from = textEvent.conversation.me.id;
				var promise_seen = textEvent.seen();
				return expect(promise_seen).to.have.been.rejected
					.then(function(error) {
						return Promise.all([
							expect(error).to.include.all.keys('stack', 'message', 'name'),
							expect(error.message).to.equal('type: error:seen:own-message, description: attempt to send seen for own message')
						]);
					});
			});

			it('should reject to send seen for already seen event', function() {
				textEvent.state = {
					seen_by: {}
				}
				textEvent.state.seen_by[textEvent.conversation.me.id] = {};
				var promise_seen = textEvent.seen();
				return expect(promise_seen).to.have.been.rejected
					.then(function(error) {
						return Promise.all([
							expect(error).to.include.all.keys('stack', 'message', 'name'),
							expect(error.message).to.equal('type: error:already-seen, description: already marked as seen')
						]);
					});
			});

			it('should resolve if event.state exists empty', function() {
				textEvent.state = {}
				var promise_seen = textEvent.seen();
				return expect(promise_seen).to.have.been.fulfilled
			});

			it('should reject with API error', function() {
				var response = {
					type: 'error:text:seen'
				}; //override the stubbed sendRequest for error
				application.session.sendRequest = function(params, callback) {
					callback({
						type: response.type
					});
				}
				var conversation = new Conversation(application);
				conversation.me = {
					id: 'some_id'
				}
				textEvent = new TextEvent(conversation, null)
				var promise_seen = textEvent.seen();
				return expect(promise_seen).to.be.rejectedWith(response.type)
					.then(function(error) {
						return Promise.all([
							expect(error).to.include.all.keys('stack', 'message', 'name'),
							expect(error.message).to.equal('type: ' + response.type + ', description: ')
						]);
					});
			});

		});

		describe('delivered()', function() {
			var textEvent;
			var application;
			var spy_sendRequest;
			var event_id = 1;
			beforeEach(function() {
				application = {
					me: {
						id: 'my user id'
					},
					session: {
						log: {
							debug: function() {}
						},
						sendRequest: function(params, callback) {
							callback({
								type: 'text:delivered:success'
							});
						}
					}
				};
				var conversation = new Conversation(application);
				conversation.id = 'cid';
				conversation.me = {
					id: 'some_id'
				}
				spy_sendRequest = sinon.spy(conversation.application.session, 'sendRequest');
				textEvent = new TextEvent(conversation, {
					id: event_id
				})
			});

			it('should resolve the promise', function() {

				var promise_delivered = textEvent.delivered();
				return expect(promise_delivered).to.be.fulfilled;
			});

			it('should send delivered for this event', function() {
				textEvent.delivered();
				return expect(spy_sendRequest).to.have.been.calledWith({
					type: 'text:delivered',
					cid: textEvent.conversation.id,
					from: textEvent.conversation.me.id,
					body: {
						"event_id": event_id
					}
				});
			});

			it('should reject to send delivered for own event', function() {
				textEvent.from = textEvent.conversation.me.id;
				var promise_delivered = textEvent.delivered();
				return expect(promise_delivered).to.have.been.rejected
					.then(function(error) {
						return Promise.all([
							expect(error).to.include.all.keys('stack', 'message', 'name'),
							expect(error.message).to.equal('type: error:delivered:own-message, description: attempt to send delivered for own message')
						]);
					});
			});

			it('should reject to send delivered for already delivered event', function() {
				textEvent.state = {
					delivered_to: {}
				}
				textEvent.state.delivered_to[textEvent.conversation.me.id] = {};
				var promise_delivered = textEvent.delivered();
				return expect(promise_delivered).to.have.been.rejected
					.then(function(error) {
						return Promise.all([
							expect(error).to.include.all.keys('stack', 'message', 'name'),
							expect(error.message).to.equal('type: error:already-delivered, description: already marked as delivered')
						]);
					});
			});

			it('should resolve if event.state exists empty', function() {
				textEvent.state = {}
				var promise_delivered = textEvent.delivered();
				return expect(promise_delivered).to.have.been.fulfilled
			});

			it('should reject with API error', function() {
				var response = {
					type: 'error:text:delivered'
				}; //override the stubbed sendRequest for error
				application.session.sendRequest = function(params, callback) {
					callback({
						type: response.type
					});
				}
				var conversation = new Conversation(application);
				conversation.me = {
					id: 'some_id'
				}
				textEvent = new TextEvent(conversation, null)
				var promise_delivered = textEvent.delivered();
				return expect(promise_delivered).to.be.rejectedWith(response.type).then(function(error) {
					return Promise.all([
						expect(error).to.include.all.keys('stack', 'message', 'name'),
						expect(error.message).to.equal('type: ' + response.type + ', description: ')
					]);
				});
			});
		});
	});
	describe('Object', function() {
		it('should be created by calling new', function() {
			var textEvent = new TextEvent();
			return expect(textEvent).to.be.an.instanceof(TextEvent);
		});
	});
});