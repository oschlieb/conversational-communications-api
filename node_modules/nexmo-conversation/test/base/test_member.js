/*
 * Conversation Client Error Test
 *
 * Copyright (c) Nexmo Inc. 2017
 */


var chai = require('chai');
var chaiAsPromised = require('chai-as-promised');
var sinon = require('sinon');
var sinonChai = require('sinon-chai');

var assert = chai.assert;
var expect = chai.expect;

chai.use(chaiAsPromised);
chai.use(sinonChai);

var utils = require('./utils');

var Conversation = require('../../lib/conversation').Conversation;
var Member = require('../../lib/member').Member;
var Event = require('../../lib/events/event').Event;

describe('Member', function() {
	var sandbox;
	beforeEach(function() {
		sandbox = sinon.sandbox.create();
	});
	afterEach(function() {
		sandbox.restore();
	});
	describe('Function', function() {
		describe('kick()', function() {
			var application;
			var member;
			var member_id = 1;
			var conversation;

			beforeEach(function() {
				application = {
					me: {
						id: 'my user id'
					},
					session: {
						log: {
							debug: function() {}
						},
						sendRequest: function(params, callback) {
							callback({
								type: 'conversation:member:delete:success'
							});
						}
					}
				};
				conversation = new Conversation(application);
				conversation.id = 'cid';
				conversation.me = {
					id: member_id
				}
				//this member will be the me member
				member = new Member(conversation, {
					id: member_id,
					user: {
						name: "username",
						id: "userid"
					},
				});
			});

			it('should resolve the promise', function() {
				var promise_del = member.kick();
				return expect(promise_del).to.be.fulfilled;
			});

			it('should send conversation:member:delete', function() {
				var sendRequestSpy = sandbox.spy(conversation.application.session, 'sendRequest');
				member.kick();
				return expect(sendRequestSpy).to.have.been.calledWithMatch({
					type: 'conversation:member:delete',
					cid: member.conversation.id,
					from: member.id,
					body: {
						"member_id": member.id
					}
				});
			});

			it('should reject with API error', function() {
				var response = {
					type: 'error:conversation:member:delete'
				}; //override the stubbed sendRequest for error
				application.session.sendRequest = function(params, callback) {
					callback({
						type: response.type
					});
				}
				var conversation = new Conversation(application);
				conversation.me = {
					id: 'some_id'
				}
				member = new Member(conversation, {
					id: member.id,
					user: {
						name: "username",
						id: "userid"
					},
				});
				member = new Member(conversation, member)
				var promise_del = member.kick();
				return expect(promise_del).to.be.rejectedWith(response.type).then(function(error) {
					return Promise.all([
						expect(error).to.include.all.keys('stack', 'message', 'name'),
						expect(error.message).to.equal('type: ' + response.type + ', description: ')
					]);
				});
			});
		});
	});
	describe('Events:', function() {
		var application;
		var member;
		var conversation;
		var member_id = 1;
		var event;

		beforeEach(function() {
			member_id = 1;
			application = {
				me: {
					id: 'my user id'
				},
				session: {
					log: {
						debug: function() {}
					},
					sendRequest: function(params, callback) {
						callback({
							type: 'conversation:member:delete:success'
						});
					}
				}
			};
			conversation = new Conversation(application);
			conversation.id = 'cid';
			conversation.me = {
				id: member_id
			}
			//this member will be the me member
			member = new Member(conversation, {
				id: member_id,
				user: {
					name: "username",
					id: "userid"
				}
			});
			conversation.members[member.id] = member;
		});
		describe('member:media event', function() {
			describe('audio true', function() {
				beforeEach(function() {
					event = {
						"from": member.id,
						"body": {
							"audio": true
						},
						"id": 6,
						"timestamp": "2017-11-16T17:31:59.867Z",
						"cid": conversation.id,
						"type": "member:media"
					}
				});
				it('_handleEvent() member:media enabled', function() {
					conversation._handleEvent(event);
					return expect(member.media).to.haveOwnProperty("audio", true);
				});

				it('should emit it in the conversation object', function() {
					spy_emit = sandbox.spy(conversation, 'emit');
					conversation._handleEvent(event);
					return expect(spy_emit).to.been.calledWith(event.type, conversation.members[member.id]);
				});
				it('should emit the event object', function(done) {
					conversation.on('member:media', function(from, incoming_event) {
						expect(incoming_event.type).to.equal("member:media");
						expect(incoming_event.body.audio).to.equal(event.body.audio);
						expect(incoming_event.constructor.name).to.equal("Event");
						done();
					});
					conversation._handleEvent(event);
				});
			});

			describe('audio false', function() {
				beforeEach(function() {
					event = {
						"from": member.id,
						"body": {
							"audio": false
						},
						"id": 6,
						"timestamp": "2017-11-16T17:31:59.867Z",
						"cid": conversation.id,
						"type": "member:media"
					}
				});
				it('_handleEvent() member:media disabled', function() {
					conversation._handleEvent(event);
					return expect(member.media).to.haveOwnProperty("audio", false);
				});
				it('should emit it in the conversation object', function() {
					spy_emit = sandbox.spy(conversation, 'emit');
					conversation._handleEvent(event);
					return expect(spy_emit).to.been.calledWith(event.type, conversation.members[member.id]);
				});
				it('should emit the event object', function(done) {
					conversation.on('member:media', function(from, incoming_event) {
						expect(incoming_event.type).to.equal("member:media");
						expect(incoming_event.body.audio).to.equal(event.body.audio);
						expect(incoming_event.constructor.name).to.equal("Event");
						done();
					});
					conversation._handleEvent(event);
				});
			});
		});
		describe('member:joined event', function() {
			beforeEach(function() {
				event = utils.events_from_cs.member_joined_app;
			});
			describe('_handleEvent() the event and update its properties', function() {
				it('should update the state', function() {
					member._handleEvent(event);
					return expect(member.state).to.equal("JOINED");
				});
				it('should update the timestamp', function() {
					member._handleEvent(event);
					return expect(member.timestamp.joined).to.equal(event.body.timestamp.joined);
				});
				it('should update the user id', function() {
					member._handleEvent(event);
					return expect(member.user.id).to.equal(event.body.user.user_id);
				});
				it('should update the user name', function() {
					member._handleEvent(event);
					return expect(member.user.name).to.equal(event.body.user.name);
				});
			});
		});
	});

	describe('Object', function() {
		var application = null;
		var conversation = null;
		beforeEach(function() {
			application = {
				me: {
					id: "my_id"
				},
				session: {}
			};
			conversation = new Conversation(application);
		});
		it('should be created by calling new', function() {
			var member = new Member();
			return expect(member).to.be.an.instanceof(Member);
		});
		it('should hold channel information on member:joined type phone', function() {
			var event = utils.events_from_cs.member_join_phone;
			conversation._handleEvent(event);
			return Promise.all([
				expect(conversation.members[event.from].state).to.equal("JOINED"),
				expect(conversation.members[event.from].invited_by).to.equal(event.body.invited_by),
				expect(conversation.members[event.from].user.id).to.equal(event.body.user.id),
				expect(conversation.members[event.from].user.name).to.equal(event.body.user.name),
				expect(conversation.members[event.from].channel).to.exist,
				expect(event.body.user.user_id).to.not.exist
			]);
		});
		it('should have the user object on member:joined', function() {
			var event = utils.events_from_cs.member_joined_app;
			conversation._handleEvent(event);
			return Promise.all([
				expect(conversation.members[event.from].state).to.equal("JOINED"),
				expect(conversation.members[event.from].invited_by).to.equal(event.body.invited_by),
				expect(conversation.members[event.from].user.id).to.equal(event.body.user.id),
				expect(conversation.members[event.from].user.name).to.equal(event.body.user.name),
				// expect(event.body.channel).to.exist,
				expect(event.body.user.user_id).to.not.exist
			]);
		});
		it('should have the user object on member:invited', function() {
			var event = utils.events_from_cs.member_invited_app;
			conversation._handleEvent(event);
			return Promise.all([
				expect(conversation.members[event.from].state).to.equal("INVITED"),
				expect(conversation.members[event.from].invited_by).to.equal(event.body.invited_by),
				expect(conversation.members[event.from].user.id).to.equal(event.body.user.id),
				expect(conversation.members[event.from].user.name).to.equal(event.body.user.name),
				// expect(event.body.channel).to.exist,
				expect(event.body.user.user_id).to.not.exist
			]);
		});
		it('should have the user object on member:left', function() {
			var event = utils.events_from_cs.member_left_app;
			conversation._handleEvent(event);
			return Promise.all([
				expect(conversation.members[event.from].state).to.equal("LEFT"),
				expect(conversation.members[event.from].invited_by).to.equal(event.body.invited_by),
				expect(conversation.members[event.from].user.id).to.equal(event.body.user.id),
				expect(conversation.members[event.from].user.name).to.equal(event.body.user.name),
				// expect(event.body.channel).to.exist,
				expect(event.body.user.user_id).to.not.exist
			]);
		});
	});
});