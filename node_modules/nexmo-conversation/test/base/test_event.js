/*
 * Conversation Client Event Test
 *
 * Copyright (c) Nexmo Inc. 2017
 */


var chai = require('chai');
var chaiAsPromised = require('chai-as-promised');
var sinon = require('sinon');
var sinonChai = require('sinon-chai');

var assert = chai.assert;
var expect = chai.expect;

chai.use(chaiAsPromised);
chai.use(sinonChai);
var Conversation = require('../../lib/conversation').Conversation;
var Event = require('../../lib/events/event').Event;

describe('Event', function() {
	describe('Function', function() {
		describe('deleteEvent()', function() {
			var event;
			var application;
			var spy_sendRequest;
			var event_id = 1;
			beforeEach(function() {
				application = {
					me: {
						id: 'my user id'
					},
					session: {
						log: {
							debug: function() {}
						},
						sendRequest: function(params, callback) {
							callback({
								type: 'event:delete:success'
							});
						}
					}
				};
				var conversation = new Conversation(application);
				conversation.id = 'cid';
				conversation.me = {
					id: 'some_id'
				}
				spy_sendRequest = sinon.spy(conversation.application.session, 'sendRequest');
				event = new Event(conversation, {
					id: event_id
				})
			});

			it('should resolve the promise', function() {

				var promise_del = event.deleteEvent(event_id);
				return expect(promise_del).to.be.fulfilled;
			});

			it('should send event:delete', function() {
				var other_event = "3";
				event.deleteEvent(other_event);
				return expect(spy_sendRequest).to.have.been.calledWith({
					type: 'event:delete',
					cid: event.conversation.id,
					from: event.conversation.me.id,
					body: {
						"event_id": other_event
					}
				});
			});

			it('should delete this event if no event id is passed error', function() {
				event.deleteEvent();
				return expect(spy_sendRequest).to.have.been.calledWith({
					type: 'event:delete',
					cid: event.conversation.id,
					from: event.conversation.me.id,
					body: {
						"event_id": event_id
					}
				});
			});

			it('should reject with API error', function() {
				var response = {
					type: 'error:event:delete'
				}; //override the stubbed sendRequest for error
				application.session.sendRequest = function(params, callback) {
					callback({
						type: response.type
					});
				}
				var conversation = new Conversation(application);
				conversation.me = {
					id: 'some_id'
				}
				event = new Event(conversation, null)
				var promise_del = event.deleteEvent();
				return expect(promise_del).to.be.rejectedWith(response.type).then(function(error) {
					return Promise.all([
						expect(error).to.include.all.keys('stack', 'message', 'name'),
						expect(error.message).to.equal('type: ' + response.type + ', description: ')
					]);
				});
			});
		});
	});
	describe('Object', function() {
		it('should be created by calling new', function() {
			var event = new Event();
			return expect(event).to.be.an.instanceof(Event);
		});
	});
});