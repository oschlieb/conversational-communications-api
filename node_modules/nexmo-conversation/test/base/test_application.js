/*
 * Application Test
 *
 * Copyright (c) Nexmo Inc. 2017
 */

var chai = require('chai');
var chaiAsPromised = require('chai-as-promised');
var sinon = require('sinon');
var sinonChai = require('sinon-chai');

var assert = chai.assert;
var expect = chai.expect;

chai.use(chaiAsPromised);
chai.use(sinonChai);

var Application = require('../../lib/application').Application;
var Conversation = require('../../lib/conversation').Conversation;
var NexmoApiError = require('../../lib/conversationClientError').NexmoApiError;

describe('Application', function() {
	var application;
	var session;
	var params;
	var sandbox;

	beforeEach(function() {
		session = {
			sendRequest: function() {
				return Promise.resolve();
			}
		};
		params = {
			'me': {
				'id': '2'
			}
		};
		application = new Application(session, params);
		sandbox = sinon.sandbox.create();

	});

	afterEach(function() {
		sandbox.restore();
	})

	describe('_handleEvent()', function() {
		var event;
		describe('receiving member:invited', function() {
			event = {
				from: 'from_id',
				body: {
					user: {}
				},
				type: "member:invited",
				cid: "conversation_cid_value"
			}

			it('should emit the event in known conversation object', function(done) {
				// seems like sometimes it needs time to setup... 
				// the time issue that appears must be because of the init of karma and the rest of the tools, rather than this test it self
				this.timeout(4000);
				var conversation = new Conversation(application, {
					id: event.cid
				});
				application.conversations[event.cid] = conversation;
				application.conversations[event.cid]._handleEvent = function(received_event) {
					assert.equal(received_event.type, event.type);
					assert.equal(received_event.cid, event.cid);
					done();
					//TODO assert event format

				};
				var handleEventSpy = sandbox.spy(application.conversations[event.cid], '_handleEvent');
				application._handleEvent(event);
				expect(handleEventSpy).to.have.been.called;
			});

			it('should trigger getConversation if the conversation is unknown', function() {
				var conversation = {
					members: {}
				};
				application.getConversation = function() {
					return Promise.resolve(conversation);
				};
				var getConversationSpy = sandbox.spy(application, 'getConversation');
				application._handleEvent(event);
				return expect(getConversationSpy).to.have.been.calledWith(event.cid);
			});
			// This case triggers an async event that we don't need to wait in the code. 
			// Therefore the aproach with 'done' is the mose reliable 
			it('should emit the event in application if the conversation is unknown', function(done) {
				var self = this;
				var conversation = {
					members: {}
				};
				application.getConversation = function() {
					return Promise.resolve(conversation);
				};
				self.targetFunction = function() {
					//TODO assert event format 
					done();
				};
				application.on(event.type, function(from, data) {
					self.targetFunction(data);
				});
				application._handleEvent(event);
			});
		});

		describe('receiving member:joined', function() {
			event = {
				from: 'from_id',
				body: {
					user: {}
				},
				type: "member:joined",
				cid: "conversation_cid_value"
			}

			it('should emit in known conversation object', function(done) {
				application.conversations[event.cid] = {
					_handleEvent: function(received_event) {
						assert.equal(received_event.body, event.body);
						assert.equal(received_event.type, event.type);
						assert.equal(received_event.cid, event.cid);
						done();
					}
				};
				var handleEventSpy = sandbox.spy(application.conversations[event.cid], '_handleEvent');
				application._handleEvent(event);
				return expect(handleEventSpy).to.have.been.called;
			});
			// This case triggers an async event that we don't need to wait in the code. 
			// Therefore the aproach with 'done' is the mose reliable 
			it('should emit in application if conversation is not known', function(done) {
				var self = this;
				var conversation = {
					members: {}
				};
				application.getConversation = function() {
					return Promise.resolve(conversation);
				};
				self.targetFunction = function(received_event) {
					//fix assert to expect type Event 
					// TODO assert the structure of the event after the alignment ticket
					// TODO update constructor and class with new JS and fix assertion
					expect(received_event.constructor.name).to.equal('Event');
					// assert.equal(received_event, event.body);
					// assert.equal(received_event.type, event.type);
					// assert.equal(received_event.cid, event.cid);
					done();
				};
				application.on(event.type, function(from, data) {
					self.targetFunction(data);
				});
				application._handleEvent(event)
			});
		});
	});

	describe('newConversation()', function() {
		it('should call sendRequest with type new:conversation', function() {
			var sendRequestSpy = sandbox.spy(application.session, 'sendRequest');
			application.newConversation();
			return expect(sendRequestSpy).to.have.been.calledWith({
				type: "new:conversation",
				body: undefined
			});
		});

		it('should call sendRequest with accepted params', function() {
			var sendRequestSpy = sandbox.spy(application.session, 'sendRequest');
			var testParams = {
				test_key: 'test_value',
				test_key2: "test value 2"
			};
			application.newConversation(testParams);
			return expect(sendRequestSpy).to.have.been.calledWith({
				type: "new:conversation",
				body: testParams
			});
		});

		describe('on new:conversation:success', function() {
			beforeEach(function() {
				session = {
					sendRequest: function(params, callback) {
						callback({
							type: "new:conversation:success",
							body: {
								id: '1'
							}
						});
					}
				};
				params = {
					'me': {
						'id': '2'
					}
				};
				application = new Application(session, params);
				var conversation = {
					members: {}
				};
				application.getConversation = function() {
					return Promise.resolve(conversation);
				};
			});

			it('should trigger getConversation', function() {
				var getConversationSpy = sandbox.spy(application, 'getConversation');
				application.newConversation();
				return expect(getConversationSpy).to.have.been.called;
			});
		});

		describe('on failure', function() {
			beforeEach(function() {
				session = {
					sendRequest: function(params, callback) {
						callback({
							type: "error:new:conversation",
							body: {
								id: '1'
							}
						});
					}
				};
				params = {
					'me': {
						'id': '2'
					}
				};
				application = new Application(session, params);
				var conversation = {
					members: {}
				};
				application.getConversation = function() {
					return Promise.resolve(conversation);
				};
			});

			it('should return a NexmoApiError object', function() {
				var newConversationPromise = application.newConversation();
				return expect(newConversationPromise).to.be.rejectedWith(new NexmoApiError());
			});
		});
	});

	describe('getUser()', function() {

		describe('with user_id param', function() {
			it('should triger sendRequest with a specific user_id', function() {
				var getUserSpy = sandbox.spy(session, 'sendRequest');
				//request user with id 1
				application.getUser('1');
				//expect user with id 1
				var expected_call_with = {
					body: {
						user_id: '1'
					},
					from: params.me.id,
					type: 'user:get'
				};
				return expect(getUserSpy).to.have.been.calledWith(expected_call_with);
			});
		});

		describe('with no params', function() {
			it('should triger sendRequest with self user_id', function() {
				var getUserSpy = sandbox.spy(session, 'sendRequest');
				//request your user details
				application.getUser();
				//expect your user details
				var expected_call_with = {
					body: {
						user_id: params.me.id
					},
					from: params.me.id,
					type: 'user:get'
				};
				return expect(getUserSpy).to.have.been.calledWith(expected_call_with);
			});
		});
	});

	describe('newConversationAndJoin()', function() {
		var conversation;

		beforeEach(function() {
			conversation = new Conversation(application);
			// attach this to identify the conversation object in the resolved promise
			conversation.cid = "identify cid";

			conversation.join = function() {
				return Promise.resolve();
			};

			application.newConversation = function() {
				return Promise.resolve(conversation);
			};
		});

		it('should return a conversation object', function() {
			var promise_newConversationAndJoin = application.newConversationAndJoin();
			return expect(promise_newConversationAndJoin).to.eventually.have.property('cid');
		});

		it('should call newConversation', function() {
			var newConversationSpy = sandbox.spy(application, 'newConversation');
			return application.newConversationAndJoin().then(function() {
				return expect(newConversationSpy).to.have.been.called;
			});
		});

		it('should call join conversation', function() {
			var joinSpy = sandbox.spy(conversation, 'join');
			return application.newConversationAndJoin().then(function() {
				return expect(joinSpy).to.have.been.called;
			});
		});
	});
});