/*
 * Conversation Test
 *
 * Copyright (c) Nexmo Inc. 2017
 */

var chai = require('chai');

var expect = chai.expect;
var chaiAsPromised = require("chai-as-promised");
var sinon = require('sinon');
var sinonChai = require("sinon-chai");

chai.use(chaiAsPromised);
chai.use(sinonChai);

var utils = require('./utils');

var Conversation = require('../../lib/conversation').Conversation;
var TextEvent = require('../../lib/events/text_event').TextEvent;
var Member = require('../../lib/member').Member;

describe('Conversation', function() {
	var member_id = '3';
	var event_id = '2';
	var conversation_id = '1';
	var params = {
		id: conversation_id
	}
	describe('Function', function() {
		describe('updateObjectInstance()', function() {
			var conversation;
			var application;
			beforeEach(function() {
				var user_id = '4';
				var member_name = 'member name';
				application = {
					me: {
						id: user_id,
						name: member_name
					},
					session: {
						sendRequest: function() {}
					}
				};
				conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};
				sendRequestSpy = sinon.spy(application.session, 'sendRequest');
			});

			it('should set the name from the params', function() {
				var new_name = 'new name';
				var old_name = conversation.name;
				conversation.updateObjectInstance(conversation.application, {
					name: new_name
				});
				return expect(conversation.name).to.equal(new_name)
					.and.not.equal(old_name);
			});

			it('should set the id from the params', function() {
				var new_id = 'new id';
				var old_id = conversation.id
				conversation.updateObjectInstance(conversation.application, {
					id: new_id
				});
				return expect(conversation.id).to.equal(new_id)
					.and.not.equal(old_id);
			});

			it('should set the display_name from the params', function() {
				var new_display_name = 'new display_name';
				var old_display_name = conversation.display_name
				conversation.updateObjectInstance(conversation.application, {
					display_name: new_display_name
				});
				return expect(conversation.display_name).to.equal(new_display_name)
					.and.not.equal(old_display_name);
			});

			it('should set the timestamp from the params', function() {
				var new_timestamp = 'new timestamp';
				var old_timestamp = conversation.timestamp
				conversation.updateObjectInstance(conversation.application, {
					timestamp: new_timestamp
				});
				return expect(conversation.timestamp).to.equal(new_timestamp)
					.and.not.equal(old_timestamp);
			});

			it('should set the sequence_number from the params', function() {
				var new_sequence_number = 'new sequence_number';
				var old_sequence_number = conversation.sequence_number
				conversation.updateObjectInstance(conversation.application, {
					sequence_number: new_sequence_number
				});
				return expect(conversation.sequence_number).to.equal(new_sequence_number)
					.and.not.equal(old_sequence_number);
			});

			it('should update a self member ', function() {
				var new_member_id = 0;
				var old_member_id = conversation.me.id;
				conversation.updateObjectInstance(conversation.application, {
					member_id: new_member_id
				});
				return expect(conversation.me.id).to.equal(new_member_id)
					.and.not.equal(old_member_id);
			});

			it('should update the members\' list', function() {
				var new_members_cs = utils.events_from_cs.conversation_get_success.members;
				//make one member to be me
				new_members_cs[1].user_id = application.me.id;
				new_members_cs[1].name = application.me.name;

				conversation.updateObjectInstance(conversation.application, {
					members: new_members_cs
				});
				return Promise.all([
					//the me member should the one with the same user_id
					expect(conversation.me.user.id).to.equal(application.me.id),
					expect(conversation.me.user.name).to.equal(new_members_cs[1].name),
					expect(conversation.me.invited_by).to.equal(new_members_cs[1].invited_by),
					expect(conversation.me.id).to.equal(new_members_cs[1].member_id),
					expect(conversation.me.state).to.equal(new_members_cs[1].state),
					expect(conversation.me.timestamp).to.equal(new_members_cs[1].timestamp),
					expect(conversation.me.invited_by).to.equal(new_members_cs[1].invited_by),
					// the member list should have both members
					expect(conversation.members[new_members_cs[0].member_id].id).to.equal(new_members_cs[0].member_id),
					expect(conversation.members[new_members_cs[0].member_id].user.id).to.equal(new_members_cs[0].user_id),
					expect(conversation.members[new_members_cs[0].member_id].user.name).to.equal(new_members_cs[0].name),
					expect(conversation.members[new_members_cs[0].member_id].state).to.equal(new_members_cs[0].state),
					expect(conversation.members[new_members_cs[0].member_id].timestamp).to.equal(new_members_cs[0].timestamp),
					expect(conversation.members[new_members_cs[1].member_id].user.id).to.equal(new_members_cs[1].user_id),
					expect(conversation.members[new_members_cs[1].member_id].user.name).to.equal(new_members_cs[1].name),
					expect(conversation.members[new_members_cs[1].member_id].state).to.equal(new_members_cs[1].state),
					expect(conversation.members[new_members_cs[1].member_id].timestamp).to.equal(new_members_cs[1].timestamp),
					expect(conversation.members[new_members_cs[1].member_id].invited_by).to.equal(new_members_cs[1].invited_by)
				]);
			});
		});

		describe('sendText()', function() {
			it('should send text request', function() {
				var application = {
					session: {
						sendRequest: function() {}
					}
				};
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};
				var text = "hi";
				var spy_sendText = sinon.spy(application.session, 'sendRequest');
				conversation.sendText(text);

				return expect(spy_sendText).to.have.been.calledWithMatch({
					type: 'text',
					cid: conversation.id,
					from: conversation.me.id,
					body: {
						text: text
					}
				});
			});

			it('should resolve the promise on success', function() {
				var response = {
					type: 'text:success',
					body: {
						id: 'eventid',
						timestamp: 'timestamp'
					}
				};
				var application = {
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};

				var prmise_sendText = conversation.sendText("hi");

				return expect(prmise_sendText).to.be.fulfilled;
			});

			it('should reject the promise on API error', function() {
				var response = {
					type: 'error:text'
				};
				var application = {
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};

				var promise_text = conversation.sendText("hi");

				return expect(promise_text).to.be.rejectedWith('error:text').then(function(error) {
					return Promise.all([
						expect(error).to.include.all.keys('stack', 'message', 'name'),
						expect(error.message).to.equal('type: error:text, description: ')
					]);
				});
			});
		});

		describe('startTyping()', function() {
			it('should send text:typing:on request', function() {
				var application = {
					session: {
						sendRequest: function() {}
					}
				};
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};
				var sendRequestSpy = sinon.spy(application.session, 'sendRequest');
				conversation.startTyping();
				return expect(sendRequestSpy).to.have.been.calledWithMatch({
					type: 'text:typing:on'
				});
			});
		});

		describe('stopTyping()', function() {
			it('should send text:typing:off request', function() {
				var application = {
					session: {
						sendRequest: function() {}
					}
				};
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};
				var sendRequestSpy = sinon.spy(application.session, 'sendRequest');
				conversation.stopTyping();
				return expect(sendRequestSpy).to.have.been.calledWithMatch({
					type: 'text:typing:off'
				});
			});
		});

		describe('del()', function() {
			it('should send conversation:delete request', function() {
				var application = {
					session: {
						sendRequest: function() {}
					}
				};
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};
				var sendRequestSpy = sinon.spy(application.session, 'sendRequest');
				conversation.del();

				return expect(sendRequestSpy).to.have.been.calledWithMatch({
					type: 'conversation:delete',
					cid: conversation.id
				});
			});

			it('should reject the promise on failure to delete', function() {
				var response = {
					type: 'conversation:delete:error'
				};
				var application = {
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};
				var delPromise = conversation.del();
				return expect(delPromise).to.be.rejectedWith(response.type).then(function(error) {
					return Promise.all([
						expect(error).to.include.all.keys('stack', 'message', 'name'),
						expect(error.message).to.equal('type: ' + response.type + ', description: ')
					]);
				});
			});

			it('should remove the conversation object from the application on successful delete', function() {
				var response = {
					type: 'conversation:delete:success'
				};
				var application = {
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};
				application.conversations = [];
				application.conversations[conversation.id] = conversation;
				return conversation.del().then(function() {
					return expect(application.conversations[conversation.id]).to.not.exist;
				});
			});

			it('should not remove the conversation object from the application on failed delete', function() {
				var response = {
					type: 'conversation:delete:error'
				};
				var application = {
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};
				application.conversations = [];
				application.conversations[conversation.id] = conversation;
				return conversation.del().catch(function(error) {
					return Promise.all([
						expect(error).to.include.all.keys('stack', 'message', 'name'),
						expect(error.message).to.equal('type: ' + response.type + ', description: '),
						expect(application.conversations[conversation.id]).to.exist
					]);

				});


			});
			//TODO add tests/remove from persistence
			it('should remove the conversation object from the IndexedDB')
		});

		describe('deleteEvent()', function() {
			it('should send event:delete request', function() {
				var application = {
					session: {
						sendRequest: function() {}
					}
				};
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};
				var sendRequestSpy = sinon.spy(application.session, 'sendRequest');
				var expectedParams = {
					type: 'event:delete',
					from: member_id,
					body: {
						event_id: event_id
					}
				}
				var text = new TextEvent(conversation, {
					cid: conversation.id,
					from: member_id,
					id: event_id,
					body: {
						text: 'text here'
					}
				});
				conversation.deleteEvent(text);
				return expect(sendRequestSpy).to.have.been.calledWithMatch(expectedParams);
			});

			it('should resolve the promise on success', function() {})

			it('should reject the promise on API error', function() {
				var response = {
					type: 'error:event:delete'
				};
				var application = {
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};
				var text = new TextEvent(conversation, {
					cid: conversation.id,
					from: member_id,
					id: event_id,
					body: {
						text: 'text here'
					}
				});
				var promise_deleteEvent = conversation.deleteEvent(text);

				return expect(promise_deleteEvent).to.be.rejectedWith(response.type).then(function(error) {
					return Promise.all([
						expect(error).to.include.all.keys('stack', 'message', 'name'),
						expect(error.message).to.equal('type: ' + response.type + ', description: ')
					]);
				});
			});
		});

		describe('getEvents()', function() {

		});

		describe('invite()', function() {
			it('should reject with error:missing:params', function() {
				var application = {
					session: {
						sendRequest: function() {}
					}
				};
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};
				var invitePromise = conversation.invite();
				return expect(invitePromise).to.be.rejectedWith('error:missing:params').then(function(error) {
					return Promise.all([
						expect(error).to.include.all.keys('stack', 'message', 'name'),
						expect(error.message).to.equal('type: error:missing:params, description: This invite cannot be sent to empty username and user_id')
					]);
				});
			});

			it('should resolve the promise on success', function() {
				var response = {
					type: 'conversation:invite:success'
				};
				var application = {
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};

				var promise_invite = conversation.invite({
					id: 'user id'
				});

				return expect(promise_invite).to.be.fulfilled;
			});

			it('should reject the promise on API error', function() {
				var response = {
					type: 'error:conversation:invite'
				};
				var application = {
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};
				var promise_invite = conversation.invite({
					user_name: "user"
				});

				return expect(promise_invite).to.be.rejectedWith(response.type).then(function(error) {
					return Promise.all([
						expect(error).to.include.all.keys('stack', 'message', 'name'),
						expect(error.message).to.equal('type: ' + response.type + ', description: ')
					]);
				});
			});
		});

		describe.skip('inviteWithAudio()', function() {
			it('should resolve the promise on success', function() {
				var application = {
					session: {
						sendRequest: function(request, callback) {
							callback({
								type: 'conversation:invite:success',
								body: {
									id: 'member id'
								}
							});
						}
					}
				};
				var params = {
					id: '1',
					user_name: 'username',
					media: {
						audio: {
							muted: false,
							earmuffed: false
						}
					}
				};
				var conversation = new Conversation(application);
				conversation.me = {
					id: member_id
				};

				var promise_inviteWithAudio = conversation.inviteWithAudio(params);

				return expect(promise_inviteWithAudio).to.be.fulfilled
			});

			it('should trigger invite passing the media params', function() {
				var application = {
					session: {
						sendRequest: function(request, callback) {
							callback({
								type: 'conversation:invite:success',
								body: {
									id: 'member id'
								}
							});
						}
					}
				};
				var params = {
					id: '1',
					user_name: 'username',
					media: {
						audio: {
							muted: false,
							earmuffed: false
						}
					}
				};
				var conversation = new Conversation(application);
				conversation.me = {
					id: member_id
				};

				var inviteSpy = sinon.spy(conversation, 'invite');
				conversation.inviteWithAudio(params);
				return expect(inviteSpy).to.have.have.been.calledWith(params)
			});

			it('should reject for missing params', function() {
				var application = {
					session: {
						sendRequest: function(request, callback) {
							callback({
								type: 'conversation:invite:success',
								body: {
									id: 'member id'
								}
							});
						}
					}
				};
				var conversation = new Conversation(application);
				conversation.me = {
					id: member_id
				};
				var promise_inviteWithAudio = conversation.inviteWithAudio();

				return expect(promise_inviteWithAudio).to.be.rejectedWith('type: error:media:params, description: currently supported params media type= {audio:{muted:false, earmuffed:false}}');
			});

			it('should pass the rejection for missing params in the invite level', function() {
				var application = {
					session: {
						sendRequest: function(request, callback) {
							callback({
								type: 'conversation:invite:success',
								body: {
									id: 'member id'
								}
							});
						}
					}
				};
				var conversation = new Conversation(application);
				conversation.me = {
					id: member_id
				};
				var promise_inviteWithAudio = conversation.inviteWithAudio({});

				return expect(promise_inviteWithAudio).to.be.rejectedWith('type: error:missing:params, description: This invite cannot be sent to empty username and user_id');
			});
		});

		describe('join()', function() {
			it('should trigger getConversation', function() {
				var response = utils.events_from_cs.conversation_join_success;

				var application = {
					getConversation: function() {
						return Promise.resolve(conversation);
					},
					me: {
						id: member_id,
						name: 'name'
					},
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};
				var getConversationSpy = sinon.spy(application, 'getConversation');
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};
				var conversationJoinPromise = conversation.join();
				return expect(conversationJoinPromise).to.be.fulfilled.then(function() {
					return expect(getConversationSpy).to.have.been.called;
				});
			});

			it('should add the member to the conversation.members if the user_id matches the local one', function() {
				var matching_user_id = 'same_user_id';
				var member_id = 'memberid';
				var response = utils.events_from_cs.conversation_join_success;
				response.body.id = member_id;
				response.body.user_id = matching_user_id;


				var join_application = {
					getConversation: function() {
						return Promise.resolve(conversation_to_join);
					},
					me: {
						id: matching_user_id,
						name: 'name'
					},
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};

				var conversation_to_join = new Conversation(join_application);
				//no need to pass params, we only care about the response
				var conversationJoinPromise = conversation_to_join.join();
				return expect(conversationJoinPromise).to.be.fulfilled.then(function(member) {
					Promise.all([
						expect(conversation_to_join.members[member.id].id).to.equal(member.id),
						expect(conversation_to_join.members[member.id].user.id).to.equal(matching_user_id)
					]);
				});
			});

			it('should add the member to the conversation.members if the user_id does not match the local one', function() {
				var joined_member_id = 'otherMemberId';
				var joined_user_id = 'joinedUserId';
				var other_user_id = 'otherUserId';

				var response = utils.events_from_cs.conversation_join_success;
				response.body.id = joined_member_id;
				response.body.user_id = joined_user_id;

				var join_application = {
					getConversation: function() {
						return Promise.resolve(conversation_to_join);
					},
					me: {
						id: other_user_id,
						name: 'name'
					},
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};

				var conversation_to_join = new Conversation(join_application);
				//no need to pass params, we only care about the response
				var conversationJoinPromise = conversation_to_join.join();
				return expect(conversationJoinPromise).to.be.fulfilled.then(function() {
					Promise.all([
						expect(conversation_to_join.members[joined_member_id]).to.exist,
						expect(conversation_to_join.members[joined_member_id].user.id).to.equal(joined_user_id)
					]);
				});
			});

			it('should assign the received member to me if the user_id matches the local one', function() {
				var matching_user_id = 'same_user_id';
				var member_id = 'memberid';
				var response = utils.events_from_cs.conversation_join_success;
				response.body.id = member_id;
				response.body.user_id = matching_user_id;


				var join_application = {
					getConversation: function() {
						return Promise.resolve(conversation_to_join);
					},
					me: {
						id: matching_user_id,
						name: 'name'
					},
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};

				var conversation_to_join = new Conversation(join_application);
				//no need to pass params, we only care about the response
				var conversationJoinPromise = conversation_to_join.join();
				return expect(conversationJoinPromise).to.be.fulfilled.then(function() {
					return Promise.all([
						expect(conversation_to_join.me).to.exist,
						expect(join_application.me.name).to.equal(conversation_to_join.application.me.name)
					]);
				});
			});

			it('should not assign the received member to me if the user_id does not match the local one', function() {
				var joined_member_id = 'otherMemberId';
				var joined_user_id = 'joinedUserId';
				var other_user_id = 'otherUserId';
				var response = utils.events_from_cs.conversation_join_success;
				response.body.id = joined_member_id;
				response.body.user_id = joined_user_id;

				var join_application = {
					getConversation: function() {
						return Promise.resolve(conversation_to_join);
					},
					me: {
						id: other_user_id,
						name: 'name'
					},
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};

				var conversation_to_join = new Conversation(join_application);
				//no need to pass params, we only care about the response
				var conversationJoinPromise = conversation_to_join.join();
				return expect(conversationJoinPromise).to.be.fulfilled.then(function() {
					return expect(conversation_to_join.me).to.not.exist;
				});
			});

			it('should reject the promise on API error', function() {
				var response = {
					type: 'error:conversation:join'
				};

				var join_application = {
					getConversation: function() {
						return Promise.resolve();
					},
					me: {
						id: 'id',
						name: 'name'
					},
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};

				var conversation_to_join = new Conversation(join_application);

				var promise_join = conversation_to_join.join();

				return expect(promise_join).to.be.rejectedWith(response.type).then(function(error) {
					return Promise.all([
						expect(error).to.include.all.keys('stack', 'message', 'name'),
						expect(error.message).to.equal('type: ' + response.type + ', description: ')
					]);
				});
			});

			it('should send conversation:join request for self (user: name and id) if there are no params', function() {
				var response = {
					body: {
						user_id: 'user_id'
					},
					type: 'conversation:join:success'
				};
				var application = {
					getConversation: function() {
						return Promise.resolve();
					},
					me: {
						id: member_id,
						name: 'name'
					},
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};
				var sendRequestSpy = sinon.spy(application.session, 'sendRequest');
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};
				conversation.join();

				return expect(sendRequestSpy).to.have.been.calledWithMatch({
					cid: conversation.id,
					type: 'conversation:join',
					body: {
						user_id: application.me.id,
						user_name: application.me.name
					}
				}).and.not.to.have.been.calledWithMatch({
					body: {
						member_id: conversation.me.id
					}
				});
			});

			it('reuse member id if we are invited', function() {
				var response = {
					body: {
						user_id: 'user_id'
					},
					type: 'conversation:join:success'
				};
				var application = {
					getConversation: function() {
						return Promise.resolve();
					},
					me: {
						id: member_id,
						name: 'name'
					},
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};
				var sendRequestSpy = sinon.spy(application.session, 'sendRequest');
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id,
					state: "INVITED"
				};
				conversation.join();

				return expect(sendRequestSpy).to.have.been.calledWithMatch({
					cid: conversation.id,
					type: 'conversation:join',
					body: {
						user_id: application.me.id,
						user_name: application.me.name,
						member_id: conversation.me.id
					}
				});
			});

			it('should send conversation:join request for another user id when passing id', function() {
				var response = {
					body: {
						user_id: 'user_id'
					},
					type: 'conversation:join:success'
				};
				var application = {
					getConversation: function() {
						return Promise.resolve();
					},
					me: {
						id: member_id,
						name: 'name'
					},
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};
				var sendRequestSpy = sinon.spy(application.session, 'sendRequest');
				var conversation = new Conversation(application, params);
				var user_to_join = {
					user_id: 'userid'
				}
				conversation.join(user_to_join);

				return expect(sendRequestSpy).to.have.been.calledWithMatch({
					cid: conversation.id,
					type: 'conversation:join',
					body: {
						user_id: user_to_join.user_id
					}
				}).and.not.to.have.been.calledWithMatch({
					body: {
						user_name: application.me.name
					}
				});
			});

			it('should send conversation:join for another user name when passing name', function() {
				var response = {
					body: {
						user_id: 'user_id'
					},
					type: 'conversation:join:success'
				};
				var application = {
					getConversation: function() {
						return Promise.resolve();
					},
					me: {
						id: member_id,
						name: 'name'
					},
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};
				var sendRequestSpy = sinon.spy(application.session, 'sendRequest');
				var conversation = new Conversation(application, params);
				var user_to_join = {
					user_name: 'username'
				}
				conversation.join(user_to_join);

				return expect(sendRequestSpy).to.have.been.calledWithMatch({
					cid: conversation.id,
					type: 'conversation:join',
					body: {
						user_name: user_to_join.user_name
					}
				}).and.not.to.have.been.calledWithMatch({
					body: {
						user_id: application.me.id
					}
				});
			});

			it('should send conversation:join for another user even if self is in INVITED state', function() {
				var response = {
					body: {
						user_id: 'user_id'
					},
					type: 'conversation:join:success'
				};
				var application = {
					getConversation: function() {
						return Promise.resolve();
					},
					me: {
						id: member_id,
						name: 'name'
					},
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};
				var sendRequestSpy = sinon.spy(application.session, 'sendRequest');
				var conversation = new Conversation(application, params);
				var user_to_join = {
					user_name: 'username'
				}
				conversation.me = {
					id: member_id,
					state: "INVITED"
				};
				conversation.join(user_to_join);

				return expect(sendRequestSpy).to.have.been.calledWithMatch({
					cid: conversation.id,
					type: 'conversation:join',
					body: {
						user_name: user_to_join.user_name
					}
				}).and.not.to.have.been.calledWithMatch({
					body: {
						member_id: conversation.me.id
					}
				});
			});
		});

		describe('leave()', function() {
			it('should send conversation:member:delete request', function() {
				var application = {
					session: {
						sendRequest: function() {}
					}
				};
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};
				var sendRequestSpy = sinon.spy(application.session, 'sendRequest');
				conversation.leave();

				return expect(sendRequestSpy).to.have.been.calledWithMatch({
					type: 'conversation:member:delete'
				});
			});

			it('should resolve the promise on success', function() {
				var response = {
					type: 'conversation:member:delete:success'
				};
				var application = {
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};

				var leavePromise = conversation.leave();

				return expect(leavePromise).to.be.fulfilled;
			});

			it('should reject the promise on API error', function() {
				var response = {
					type: 'error:conversation:member:delete'
				};
				var application = {
					session: {
						sendRequest: function(params, callback) {
							callback(response);
						}
					}
				};
				var conversation = new Conversation(application, params);
				conversation.me = {
					id: member_id
				};

				var leavePromise = conversation.leave();

				return expect(leavePromise).to.be.rejectedWith('error:conversation:member:delete').then(function(error) {
					return Promise.all([
						expect(error).to.include.all.keys('stack', 'message', 'name'),
						expect(error.message).to.equal('type: error:conversation:member:delete, description: ')
					]);
				});
			});
		});
	});

	describe('Object', function() {
		// params are checked in function section, with updateObjectInstance
		it('should be created by calling new', function() {
			var conversation = new Conversation();
			return expect(conversation).to.be.an.instanceOf(Conversation);
		});
	});

	describe('Properties', function() {
		it('should include default', function() {
			var conversation = new Conversation();
			return expect(conversation).to.include.all.keys('application', 'media', 'me', 'members', 'sequence_number');
		});
		describe('events', function() {
			it('should list member:media events', function() {
				var member = {
					id: "member_id"
				};
				var application = {
					me: {
						name: 'username',
						id: 'userid'
					},
					session: {}
				};
				var conversation = new Conversation(application);
				var event = {
					"from": member.id,
					"body": {
						"audio": true
					},
					"id": 6,
					"timestamp": "2017-11-16T17:31:59.867Z",
					"cid": conversation.id,
					"type": "member:media"
				}
				conversation.members[member.id] = new Member(conversation, member);
				conversation._handleEvent(event);
				return expect(conversation.events[event.id]).to.be.include(event);
			});
		});
		it('should ignore "from" for rtc:answer events', function() {
			var member = {
				id: "member_id"
			};
			var application = {
				me: {
					user: {
						name: 'username',
						id: 'userid'
					}
				},
				session: {}
			};
			var conversation = new Conversation(application);
			var event = {
				"body": {
					"answer": "v=0\r\no=FreLsPOpOXsmhNFBu\r\na=ice-pwd:\r\n_soref3453treÂ£@%$%$^&%&^",
					"rtc_id": "b316fae7-b444-4890-b18f-e36d1b586d77"
				},
				"timestamp": "2017-11-29T09:26:14.099Z",
				"cid": conversation.id,
				"type": "rtc:answer"
			}
			conversation.members[member.id] = new Member(conversation, member);
			conversation._handleEvent(event);
			return expect(conversation.events).to.be.empty;
		});
	});
});