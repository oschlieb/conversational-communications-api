/*
 * Media Test
 *
 * Copyright (c) Nexmo Inc. 2017
 */

var chai = require('chai');
var chaiAsPromised = require('chai-as-promised');
var sinon = require('sinon');
var sinonChai = require('sinon-chai');

chai.should();
var expect = chai.expect;

chai.use(chaiAsPromised);
chai.use(sinonChai);

var Conversation = require('../../lib/conversation').Conversation;
var Media = require('../../lib/modules/media').Media;
var RtcHelper = require('../../lib/modules/rtc_helper').RtcHelper;

describe('Media', function() {
    describe('Function', function() {
        describe('enable()', function() {
            var media;
            var conversation;
            var sandbox;

            beforeEach(function() {
                var application = {
                    me: {
                        id: 'my user id'
                    },
                    session: {
                        log: {
                            debug: function() {}
                        },
                        sendRequest: function() {}
                    }
                };
                conversation = new Conversation(application);
                media = new Media(conversation);
                sandbox = sinon.sandbox.create();
            });

            afterEach(function() {
                sandbox.restore();
            });

            it('should call getUserMedia with audio true and video false', function() {
                conversation.me = {
                    id: 'some_id'
                }
                var getUserMediaSpy = sandbox.spy(navigator.mediaDevices, 'getUserMedia');
                var enableMediaPromise = media.enable();
                // this should be rejected
                // it should fail in getUserMedia related functions for the browser API
                return enableMediaPromise.should.be.rejected
                    .then(function() {
                        return expect(getUserMediaSpy).to.be.calledWith({
                            audio: true,
                            video: false
                        });
                    });
            });

            it('should reject with error:self when our member is not defined', function() {
                var enableMediaPromise = media.enable();
                // this should be rejected
                // it should fail in getUserMedia related functions for the browser API
                return enableMediaPromise.should.be.rejectedWith('error:self').then(function(error) {
                    return Promise.all([
                        expect(error).to.include.all.keys('stack', 'message', 'name'),
                        expect(error.message).to.equal('type: error:self, description: Conversation object is missing self (me)')
                    ]);
                });
            })

            it('should reject with error:media:already-connecting', function() {
                conversation.me = {
                    id: 'some_id'
                }
                media.application.session.config = {
                    iceServers: {
                        urls: 'stun:stun.l.google.com:19302'
                    }
                }
                media.application.activeStream = {
                    stream: 'StreamObject'
                };
                var enableMediaPromise = media.enable();

                return expect(enableMediaPromise).to.be.rejectedWith('error:media:already-connecting').then(function(error) {
                    return Promise.all([
                        expect(error).to.include.all.keys('stack', 'message', 'name'),
                        expect(error.message).to.equal('type: error:media:already-connecting, description: Media is already in progress')
                    ]);

                });
            });

        });

        describe('enable video', function() {
            var media;
            var conversation;
            var sandbox;

            beforeEach(function() {
                var application = {
                    me: {
                        id: 'my user id'
                    },
                    session: {
                        log: {
                            debug: function() {}
                        },
                        sendRequest: function() {}
                    }
                };
                conversation = new Conversation(application);
                media = new Media(conversation);
                sandbox = sinon.sandbox.create();
                conversation.me = {
                    id: 'some_id'
                }

                conversation.media.application = {
                    me: {
                        id: 'my user id'
                    },
                    session: {
                        log: {
                            debug: function() {}
                        }
                    }
                };

                media.application.session.config = {
                    iceServers: {
                        urls: 'stun:stun.l.google.com:19302'
                    }
                }
                sandbox.stub(RTCPeerConnection.prototype, 'setLocalDescription');
            });

            afterEach(function() {
                sandbox.restore();
            });

            describe('when enabling video with both param', function() {
                var mediaEnablePromise;

                beforeEach(function() {
                    var getUserVideoMock = sandbox.stub(RtcHelper.prototype, 'getUserVideo');
                    getUserVideoMock.resolves({
                        getTracks: function() {
                            return [];
                        }
                    });
                    conversation.me.emit = function() {}
                    media.application.session.sendRequest = function(params, callback) {
                        callback({
                            body: {
                                rtc_id: 'rtc_id'
                            },
                            type: 'rtc:new:success'
                        });
                    };
                    mediaEnablePromise = media.enable({
                        video: 'both'
                    });
                });

                it('should create peer connection ', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc).to.be.exist;
                    });
                });

                it('should set ontrack', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc.ontrack).to.be.exist;
                    });
                });

                it('should set local stream', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.localStream).to.be.exist;
                    });
                });

                it('should set rtc:offer callback', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.callbacks['rtc:offer']).to.be.exist;
                    });
                });

                it('should set rtc:answer callback', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.callbacks['rtc:answer']).to.be.exist;
                    });
                });

                it('should set member:left callback', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.callbacks['member:left']).to.be.exist;
                    });
                });

                it('should set rtc:terminate callback', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.callbacks['rtc:terminate']).to.be.exist;
                    });
                });

                it('should set onicecandidate', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc.onicecandidate).to.be.exist;
                    });
                });

                it('should set onicegatheringstatechange', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc.onicegatheringstatechange).to.be.exist;
                    });
                });

                it('should call rtc:answer with success', function() {
                    return mediaEnablePromise.then(function() {
                        var setRemoteStub = sandbox.stub(conversation.pc, 'setRemoteDescription');
                        setRemoteStub.resolves();
                        conversation.emit('rtc:answer', {
                            body: {
                                answer: 'sdp'
                            }
                        });
                        return (conversation.pc.setRemoteDescription).should.have.been.calledOnce;
                    });
                });

                it('should call rtc:answer with failure', function() {
                    return mediaEnablePromise.then(function() {
                        var setRemoteStub = sandbox.stub(conversation.pc, 'setRemoteDescription');
                        setRemoteStub.rejects();
                        conversation.emit('rtc:answer', {
                            body: {
                                answer: 'sdp'
                            }
                        });
                        return (conversation.pc.setRemoteDescription).should.have.been.calledOnce;
                    });
                });

                it('should call rtc:offer', function() {
                    return mediaEnablePromise.then(function() {
                        var handleNewOfferMock = sandbox.stub(Media.prototype, '_handleNewOffer');
                        conversation.emit('rtc:offer', {
                            body: {}
                        });
                        return (handleNewOfferMock).should.have.been.calledOnce;
                    });
                });

                it('should call rtc:terminate', function() {
                    return mediaEnablePromise.then(function() {
                        var handleRtcTerminateMock = sandbox.stub(Media.prototype, '_handleParticipantRtcTerminate');
                        conversation.emit('rtc:terminate', undefined);
                        return (handleRtcTerminateMock).should.have.been.calledOnce;
                    });
                });

                it('should call onTrack', function() {
                    return mediaEnablePromise.then(function() {
                        conversation.pc.ontrack({
                            streams: ['a', 'b']
                        });
                        return expect(media.application.activeStream.stream).to.equal('a');
                    });
                });

                it('should call member:left with self', function() {
                    return mediaEnablePromise.then(function() {
                        var disableMock = sandbox.stub(media, 'disable');
                        conversation.emit('member:left', 'member:left', {
                            user: {
                                id: 'my user id'
                            }
                        });
                        return (disableMock).should.have.been.calledOnce;
                    });
                })

                it('should call member:left with other member', function() {
                    return mediaEnablePromise.then(function() {
                        var disableMock = sandbox.stub(media, 'disable');
                        conversation.emit('member:left', 'member:left', {
                            user: {
                                id: 'other user id'
                            }
                        });
                        return (disableMock).should.have.not.been.called;
                    });
                })

                it('should call onicecandidate', function() {
                    return mediaEnablePromise.then(function() {
                        var p = new Promise(function(resolve, reject) {
                            sandbox.stub(media, '_onIceCandidate').callsFake(function() {
                                resolve();
                            });
                            conversation.pc.onicecandidate();
                        });

                        return p;
                    });
                })
            })

            describe('when enabling video with true param', function() {
                var mediaEnablePromise;

                beforeEach(function() {
                    var getUserVideoMock = sandbox.stub(RtcHelper.prototype, 'getUserVideo');
                    getUserVideoMock.resolves({
                        getTracks: function() {
                            return [];
                        }
                    });
                    conversation.me.emit = function() {}
                    media.application.session.sendRequest = function(params, callback) {
                        callback({
                            body: {
                                rtc_id: 'rtc_id'
                            },
                            type: 'rtc:new:success'
                        });
                    };
                    mediaEnablePromise = media.enable({
                        video: true
                    });
                });

                it('should create peer connection ', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc).to.be.exist;
                    });
                });

                it('should set ontrack', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc.ontrack).to.be.exist;
                    });
                });

                it('should set local stream', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.localStream).to.be.exist;
                    });
                });

                it('should set rtc:offer callback', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.callbacks['rtc:offer']).to.be.exist;
                    });
                });

                it('should set rtc:answer callback', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.callbacks['rtc:answer']).to.be.exist;
                    });
                });

                it('should set member:left callback', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.callbacks['member:left']).to.be.exist;
                    });
                });

                it('should set onicecandidate', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc.onicecandidate).to.be.exist;
                    });
                });

                it('should set onicegatheringstatechange', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc.onicegatheringstatechange).to.be.exist;
                    });
                });

                it('should call rtc:answer with success', function() {
                    return mediaEnablePromise.then(function() {
                        var setRemoteStub = sandbox.stub(conversation.pc, 'setRemoteDescription');
                        setRemoteStub.resolves();
                        conversation.emit('rtc:answer', {
                            body: {
                                answer: 'sdp'
                            }
                        });
                        return (conversation.pc.setRemoteDescription).should.have.been.calledOnce;
                    });
                });

                it('should call rtc:answer with failure', function() {
                    return mediaEnablePromise.then(function() {
                        var setRemoteStub = sandbox.stub(conversation.pc, 'setRemoteDescription');
                        setRemoteStub.rejects();
                        conversation.emit('rtc:answer', {
                            body: {
                                answer: 'sdp'
                            }
                        });
                        return (conversation.pc.setRemoteDescription).should.have.been.calledOnce;
                    });
                });

                it('should call rtc:offer', function() {
                    return mediaEnablePromise.then(function() {
                        var handleNewOfferMock = sandbox.stub(Media.prototype, '_handleNewOffer');
                        conversation.emit('rtc:offer', {
                            body: {}
                        });
                        return (handleNewOfferMock).should.have.been.calledOnce;
                    });
                });

                it('should call onTrack', function() {
                    return mediaEnablePromise.then(function() {
                        conversation.pc.ontrack({
                            streams: ['a', 'b']
                        });
                        return expect(media.application.activeStream.stream).to.equal('a');
                    });
                });

                it('should call member:left with self', function() {
                    return mediaEnablePromise.then(function() {
                        var disableMock = sandbox.stub(media, 'disable');
                        conversation.emit('member:left', 'member:left', {
                            user: {
                                id: 'my user id'
                            }
                        });
                        return (disableMock).should.have.been.calledOnce;
                    });
                })

                it('should call member:left with other member', function() {
                    return mediaEnablePromise.then(function() {
                        var disableMock = sandbox.stub(media, 'disable');
                        conversation.emit('member:left', 'member:left', {
                            user: {
                                id: 'other user id'
                            }
                        });
                        return (disableMock).should.have.not.been.called;
                    });
                })

                it('should call onicecandidate', function() {
                    return mediaEnablePromise.then(function() {
                        var p = new Promise(function(resolve, reject) {
                            sandbox.stub(media, '_onIceCandidate').callsFake(function() {
                                resolve();
                            });
                            conversation.pc.onicecandidate();
                        });

                        return p;
                    });
                })
            })

            describe('when enabling video with send_only param', function() {
                var mediaEnablePromise;

                beforeEach(function() {
                    var getUserVideoMock = sandbox.stub(RtcHelper.prototype, 'getUserVideo');
                    getUserVideoMock.resolves({
                        getTracks: function() {
                            return [];
                        }
                    });
                    conversation.me.emit = function() {}
                    media.application.session.sendRequest = function(params, callback) {
                        callback({
                            body: {
                                rtc_id: 'rtc_id'
                            },
                            type: 'rtc:new:success'
                        });
                    };
                    mediaEnablePromise = media.enable({
                        video: 'send_only'
                    });
                });

                it('should create peer connection ', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc).to.be.exist;
                    });
                });

                it('should set ontrack', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc.ontrack).to.be.exist;
                    });
                });

                it('should set local stream', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.localStream).to.be.exist;
                    });
                });

                it('should not set rtc:offer callback', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.callbacks['rtc:offer']).to.not.exist;
                    });
                });

                it('should set rtc:answer callback', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.callbacks['rtc:answer']).to.be.exist;
                    });
                });

                it('should set member:left callback', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.callbacks['member:left']).to.exist;
                    });
                });

                it('should set onicecandidate', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc.onicecandidate).to.be.exist;
                    });
                });

                it('should set onicegatheringstatechange', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc.onicegatheringstatechange).to.be.exist;
                    });
                });

                it('should call rtc:answer with success', function() {
                    return mediaEnablePromise.then(function() {
                        var setRemoteStub = sandbox.stub(conversation.pc, 'setRemoteDescription');
                        setRemoteStub.resolves();
                        conversation.emit('rtc:answer', {
                            body: {
                                answer: 'sdp'
                            }
                        });
                        return (conversation.pc.setRemoteDescription).should.have.been.calledOnce;
                    });
                });

                it('should call rtc:answer with failure', function() {
                    return mediaEnablePromise.then(function() {
                        var setRemoteStub = sandbox.stub(conversation.pc, 'setRemoteDescription');
                        setRemoteStub.rejects();
                        conversation.emit('rtc:answer', {
                            body: {
                                answer: 'sdp'
                            }
                        });
                        return (conversation.pc.setRemoteDescription).should.have.been.calledOnce;
                    });
                });

                it('should call onTrack', function() {
                    return mediaEnablePromise.then(function() {
                        conversation.pc.ontrack({
                            streams: ['a', 'b']
                        });
                        return expect(media.application.activeStream.stream).to.equal('a');
                    });
                });

                it('should call member:left with self', function() {
                    return mediaEnablePromise.then(function() {
                        var disableMock = sandbox.stub(media, 'disable');
                        conversation.emit('member:left', 'member:left', {
                            user: {
                                id: 'my user id'
                            }
                        });
                        return (disableMock).should.have.been.calledOnce;
                    });
                })
                it('should call member:left with other member', function() {
                    return mediaEnablePromise.then(function() {
                        var disableMock = sandbox.stub(media, 'disable');
                        conversation.emit('member:left', 'member:left', {
                            user: {
                                id: 'other user id'
                            }
                        });
                        return (disableMock).should.have.not.been.called;
                    });
                })

                it('should call onicecandidate', function() {
                    return mediaEnablePromise.then(function() {
                        var p = new Promise(function(resolve, reject) {
                            sandbox.stub(media, '_onIceCandidate').callsFake(function() {
                                resolve();
                            });
                            conversation.pc.onicecandidate();
                        });
                        return p;
                    });
                })
            })

            describe('when enabling video with receive_only param', function() {
                var mediaEnablePromise;

                beforeEach(function() {
                    mediaEnablePromise = media.enable({
                        video: 'receive_only'
                    });
                });

                it('should be rejected', function() {
                    return mediaEnablePromise
                        .then(function() {
                            fail();
                        }).catch((e) => {
                            return expect(e).to.be.exist;
                        });
                })

            })

            describe('when enabling video with none param', function() {
                var mediaEnablePromise;

                beforeEach(function() {
                    mediaEnablePromise = media.enable({
                        video: 'none'
                    });
                });

                it('should be rejected', function() {
                    var _handleVideoSendStub = sandbox.stub(Media.prototype, '_handleVideoSend');
                    return mediaEnablePromise
                        .then(function() {
                            return expect(_handleVideoSendStub).to.have.not.been.called;
                        });
                })

            })

            describe('when enabling video with not valid param', function() {
                var mediaEnablePromise;

                beforeEach(function() {
                    mediaEnablePromise = media.enable({
                        video: 'test'
                    });
                });

                it('should be rejected', function() {
                    return mediaEnablePromise
                        .then(function() {
                            fail();
                        }).catch((e) => {
                            return expect(e).to.be.exist;
                        });
                })

            })

            describe('when rtc:new failed', function() {
                var mediaEnablePromise;
                beforeEach(function() {
                    media.application.session.sendRequest = function(params, callback) {
                        callback({
                            body: {
                                rtc_id: 'rtc_id'
                            },
                            type: 'rtc:new:failed'
                        });
                    };
                    mediaEnablePromise = media.enable({
                        video: 'both'
                    });
                });

                it('should failed', function() {
                    return mediaEnablePromise.then(function() {
                        fail();
                    }).catch(function(e) {
                        return expect(e).to.be.exist;
                    })
                })
            })
        });

        describe('enable screen sharing', function() {
            var media;
            var conversation;
            var sandbox;

            beforeEach(function() {
                var application = {
                    me: {
                        id: 'my user id'
                    },
                    session: {
                        log: {
                            debug: function() {}
                        },
                        sendRequest: function() {}
                    }
                };
                conversation = new Conversation(application);
                media = new Media(conversation);
                sandbox = sinon.sandbox.create();
                conversation.me = {
                    id: 'some_id'
                }

                conversation.media.application = {
                    me: {
                        id: 'my user id'
                    },
                    session: {
                        log: {
                            debug: function() {}
                        }
                    }
                };

                media.application.session.config = {
                    iceServers: {
                        urls: 'stun:stun.l.google.com:19302'
                    }
                }
                sandbox.stub(RTCPeerConnection.prototype, 'setLocalDescription');
            });

            afterEach(function() {
                sandbox.restore();
            });

            describe('when enabling screen sharing with send_only param', function() {
                var mediaEnablePromise;

                beforeEach(function() {
                    var getUserVideoMock = sandbox.stub(RtcHelper.prototype, 'getUserScreen');
                    getUserVideoMock.resolves({
                        getTracks: function() {
                            return [];
                        }
                    });
                    conversation.me.emit = function() {}
                    media.application.session.sendRequest = function(params, callback) {
                        callback({
                            body: {
                                rtc_id: 'rtc_id'
                            },
                            type: 'rtc:new:success'
                        });
                    };
                    mediaEnablePromise = media.enable({
                        screenshare: 'send_only'
                    });
                });

                it('should create peer connection ', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc).to.be.exist;
                    });
                });

                it('should set ontrack', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc.ontrack).to.be.exist;
                    });
                });

                it('should set local stream', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.localStream).to.be.exist;
                    });
                });

                it('should not set rtc:offer callback', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.callbacks['rtc:offer']).to.not.exist;
                    });
                });

                it('should set rtc:answer callback', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.callbacks['rtc:answer']).to.be.exist;
                    });
                });

                it('should set member:left callback', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.callbacks['member:left']).to.be.exist;
                    });
                });

                it('should set onicecandidate', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc.onicecandidate).to.be.exist;
                    });
                });

                it('should set onicegatheringstatechange', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc.onicegatheringstatechange).to.be.exist;
                    });
                });

                it('should call rtc:answer with success', function() {
                    return mediaEnablePromise.then(function() {
                        var setRemoteStub = sandbox.stub(conversation.pc, 'setRemoteDescription');
                        setRemoteStub.resolves();
                        conversation.emit('rtc:answer', {
                            body: {
                                answer: 'sdp'
                            }
                        });
                        return (conversation.pc.setRemoteDescription).should.have.been.calledOnce;
                    });
                });

                it('should call rtc:answer with failure', function() {
                    return mediaEnablePromise.then(function() {
                        var setRemoteStub = sandbox.stub(conversation.pc, 'setRemoteDescription');
                        setRemoteStub.rejects();
                        conversation.emit('rtc:answer', {
                            body: {
                                answer: 'sdp'
                            }
                        });
                        return (conversation.pc.setRemoteDescription).should.have.been.calledOnce;
                    });
                });

                it('should call onTrack', function() {
                    return mediaEnablePromise.then(function() {
                        conversation.pc.ontrack({
                            streams: ['a', 'b']
                        });
                        return expect(media.application.activeStream.stream).to.equal('a');
                    });
                });

                it('should call member:left with self', function() {
                    return mediaEnablePromise.then(function() {
                        var disableMock = sandbox.stub(media, 'disable');
                        conversation.emit('member:left', 'member:left', {
                            user: {
                                id: 'my user id'
                            }
                        });
                        return (disableMock).should.have.been.calledOnce;
                    });
                })

                it('should call member:left with other member', function() {
                    return mediaEnablePromise.then(function() {
                        var disableMock = sandbox.stub(media, 'disable');
                        conversation.emit('member:left', 'member:left', {
                            user: {
                                id: 'other user id'
                            }
                        });
                        return (disableMock).should.have.not.been.called;
                    });
                })

                it('should call onicecandidate', function() {
                    return mediaEnablePromise.then(function() {
                        var p = new Promise(function(resolve, reject) {
                            sandbox.stub(media, '_onIceCandidate').callsFake(function() {
                                resolve();
                            });
                            conversation.pc.onicecandidate();
                        });
                        return p;
                    });
                })
            })

            describe('when enabling screen sharing with true param', function() {
                var mediaEnablePromise;

                beforeEach(function() {
                    var getUserVideoMock = sandbox.stub(RtcHelper.prototype, 'getUserScreen');
                    getUserVideoMock.resolves({
                        getTracks: function() {
                            return [];
                        }
                    });
                    conversation.me.emit = function() {}
                    media.application.session.sendRequest = function(params, callback) {
                        callback({
                            body: {
                                rtc_id: 'rtc_id'
                            },
                            type: 'rtc:new:success'
                        });
                    };
                    mediaEnablePromise = media.enable({
                        screenshare: true
                    });
                });

                it('should create peer connection ', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc).to.be.exist;
                    });
                });

                it('should set ontrack', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc.ontrack).to.be.exist;
                    });
                });

                it('should set local stream', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.localStream).to.be.exist;
                    });
                });

                it('should not set rtc:offer callback', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.callbacks['rtc:offer']).to.not.exist;
                    });
                });

                it('should set rtc:answer callback', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.callbacks['rtc:answer']).to.be.exist;
                    });
                });

                it('should set member:left callback', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.callbacks['member:left']).to.be.exist;
                    });
                });

                it('should set onicecandidate', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc.onicecandidate).to.be.exist;
                    });
                });

                it('should set onicegatheringstatechange', function() {
                    return mediaEnablePromise.then(function() {
                        return expect(conversation.pc.onicegatheringstatechange).to.be.exist;
                    });
                });

                it('should call rtc:answer with success', function() {
                    return mediaEnablePromise.then(function() {
                        var setRemoteStub = sandbox.stub(conversation.pc, 'setRemoteDescription');
                        setRemoteStub.resolves();
                        conversation.emit('rtc:answer', {
                            body: {
                                answer: 'sdp'
                            }
                        });
                        return (conversation.pc.setRemoteDescription).should.have.been.calledOnce;
                    });
                });

                it('should call rtc:answer with failure', function() {
                    return mediaEnablePromise.then(function() {
                        var setRemoteStub = sandbox.stub(conversation.pc, 'setRemoteDescription');
                        setRemoteStub.rejects();
                        conversation.emit('rtc:answer', {
                            body: {
                                answer: 'sdp'
                            }
                        });
                        return (conversation.pc.setRemoteDescription).should.have.been.calledOnce;
                    });
                });

                it('should call onTrack', function() {
                    return mediaEnablePromise.then(function() {
                        conversation.pc.ontrack({
                            streams: ['a', 'b']
                        });
                        return expect(media.application.activeStream.stream).to.equal('a');
                    });
                });

                it('should call member:left with self', function() {
                    return mediaEnablePromise.then(function() {
                        var disableMock = sandbox.stub(media, 'disable');
                        conversation.emit('member:left', 'member:left', {
                            user: {
                                id: 'my user id'
                            }
                        });
                        return (disableMock).should.have.been.calledOnce;
                    });
                })

                it('should call member:left with other member', function() {
                    return mediaEnablePromise.then(function() {
                        var disableMock = sandbox.stub(media, 'disable');
                        conversation.emit('member:left', 'member:left', {
                            user: {
                                id: 'other user id'
                            }
                        });
                        return (disableMock).should.have.not.been.called;
                    });
                })

                it('should call onicecandidate', function() {
                    return mediaEnablePromise.then(function() {
                        var p = new Promise(function(resolve, reject) {
                            sandbox.stub(media, '_onIceCandidate').callsFake(function() {
                                resolve();
                            });
                            conversation.pc.onicecandidate();
                        });
                        return p;
                    });
                })
            })

            describe('when enabling screen sharing with none param', function() {
                var mediaEnablePromise;

                beforeEach(function() {
                    mediaEnablePromise = media.enable({
                        screenshare: 'none'
                    });
                });

                it('should be rejected', function() {
                    var _handleVideoSendStub = sandbox.stub(Media.prototype, '_handleVideoSend');
                    return mediaEnablePromise
                        .then(function() {
                            return expect(_handleVideoSendStub).to.have.not.been.called;
                        });
                })

            })

            describe('when rtc:new failed', function() {
                var mediaEnablePromise;
                beforeEach(function() {
                    media.application.session.sendRequest = function(params, callback) {
                        callback({
                            body: {
                                rtc_id: 'rtc_id'
                            },
                            type: 'rtc:new:failed'
                        });
                    };
                    mediaEnablePromise = media.enable({
                        screenshare: 'both'
                    });
                });

                it('should failed', function() {
                    return mediaEnablePromise.then(function() {
                        fail();
                    }).catch(function(e) {
                        return expect(e).to.be.exist;
                    })
                })


            })

        });

        describe('on iceCandidate called', function() {
            var media;
            var promiseArray = [];
            var checkParams;
            beforeEach(function() {
                var application = {
                    me: {
                        id: 'my user id'
                    },
                    session: {
                        log: {
                            debug: function() {}
                        },
                        sendRequest: function() {}
                    },
                    activeStream: {
                        rtc_id: 'rtc_id'
                    }
                };
                var conversation = new Conversation(application);
                conversation.id = 'id';
                conversation.me = {
                    id: 'me.id'
                };
                media = new Media(conversation);
                sandbox = sinon.sandbox.create();
            });
            afterEach(function() {})

            describe('when sending candidates', function() {
                beforeEach(function() {
                    var event = {
                        candidate: 'candidate'
                    }
                    var body = {};
                    media.application.session.sendRequest = function(params, callback) {
                        checkParams = params;
                        callback({
                            type: 'rtc:ice:success'
                        });
                    };
                    media._onIceCandidate(promiseArray, event, body);
                })

                it('should send candidate in the body', function() {
                    return Promise.all(promiseArray).then(function() {
                        expect(checkParams.body.candidates).to.be.equal('candidate');
                    })
                })

                it('should send the right params', function() {
                    return Promise.all(promiseArray).then(function() {
                        expect(checkParams.type).to.be.equal('rtc:ice');
                        expect(checkParams.cid).to.be.equal('id');
                        expect(checkParams.from).to.be.equal('me.id');
                        expect(checkParams.rtc_id).to.be.equal('rtc_id');
                    })
                })
            })

            describe('when sending null candidate', function() {
                var onIceCandidatePromise;
                beforeEach(function() {
                    var event = {
                        candidate: null
                    }
                    var body = {};
                    media.application.session.sendRequest = function(params, callback) {
                        checkParams = params;
                        callback({
                            type: 'rtc:ice:success'
                        });
                    };
                    onIceCandidatePromise = media._onIceCandidate(promiseArray, event, body);
                });

                it('should send completed: true in the body', function() {
                    return onIceCandidatePromise.then(function() {
                        expect(checkParams.body.candidates.completed).to.be.equal(true);
                    })
                });

                it('should send the right params', function() {
                    return onIceCandidatePromise.then(function() {
                        expect(checkParams.type).to.be.equal('rtc:ice');
                        expect(checkParams.cid).to.be.equal('id');
                        expect(checkParams.from).to.be.equal('me.id');
                        expect(checkParams.rtc_id).to.be.equal('rtc_id');
                    })
                })
            })

            describe('when sending candidates failures', function() {
                beforeEach(function() {
                    var event = {
                        candidate: null
                    }
                    var body = {};
                    media.application.session.sendRequest = function(params, callback) {
                        checkParams = params;
                        callback({
                            type: 'rtc:ice:failure'
                        });
                    };
                    media._onIceCandidate(promiseArray, event, body);
                })

                it('should return response as error', function() {
                    return Promise.all(promiseArray).then(function() {
                        fail();
                    }).catch(function(e) {
                        return expect(e).to.be.exist;
                    })
                })

            })
        })

        describe('handleNewOffer called', function() {
            var media;
            var sandbox;
            var conversation;
            beforeEach(function() {
                var application = {
                    me: {
                        id: 'my user id'
                    },
                    session: {
                        log: {
                            debug: function() {}
                        },
                        sendRequest: function() {}
                    },
                    activeStream: {
                        rtc_id: 'rtc_id'
                    }
                };
                conversation = new Conversation(application);
                conversation.id = 'id';
                conversation.me = {
                    id: 'me.id'
                };
                media = new Media(conversation);
                media.application.session.config = {
                    iceServers: {
                        urls: 'stun:stun.l.google.com:19302'
                    }
                }
                sandbox = sinon.sandbox.create();
            });

            afterEach(function() {
                sandbox.restore()
            })

            describe('when new rtc:offer event is called', function() {
                beforeEach(function() {
                    conversation.members = [];
                    conversation.remoteMembers = [];
                    conversation.members['member_id'] = {};
                    var params;
                    var event = {
                        body: {
                            member_id: 'member_id',
                            sdp: 'sdp'
                        }
                    }
                    media._handleNewOffer(params, event);
                });
                it('should add remote member to remote member list', function() {
                    return conversation.remoteMembers.should.not.be.empty;
                });
                it('should add member id', function() {
                    var remote = conversation.remoteMembers[0];
                    return remote.remote_member_id.should.be.equal('member_id');
                });
                it('should fill pc in the remote member', function() {
                    var remote = conversation.remoteMembers[0];
                    return remote.pc.should.be.exist;
                });
                it('should fill pc in the remote member', function() {
                    var remote = conversation.remoteMembers[0];
                    return remote.pc.ontrack.should.be.exist;
                });
                it('should fill pc in the remote member', function() {
                    var remote = conversation.remoteMembers[0];
                    return remote.pc.onicecandidate.should.be.exist;
                });
                it('should fill pc in the remote member', function() {
                    var remote = conversation.remoteMembers[0];
                    return remote.pc.oniceconnectionstatechange.should.be.exist;
                });
                it('should fill pc in the remote member', function() {
                    var remote = conversation.remoteMembers[0];
                    return remote.pc.onicegatheringstatechange.should.be.exist;
                });
                it('should call onTrack and emit the stream', function() {
                    var remote = conversation.remoteMembers[0];
                    var event = {
                        streams: ['stream']
                    }
                    remote.remote_member.emit = function() {}
                    var remoteEmitMock = sandbox.stub(remote.remote_member, 'emit');
                    remote.pc.ontrack(event);
                    return Promise.all([
                        expect(remoteEmitMock).to.be.calledOnce,
                        expect(remote.stream).to.be.equal('stream')
                    ]);
                })
                it('should call onTrack and not emit the stream', function() {
                    var remote = conversation.remoteMembers[0];
                    var event = {
                        streams: ['stream']
                    }
                    remote.stream = 'stream'
                    remote.remote_member.emit = function() {}
                    var remoteEmitMock = sandbox.stub(remote.remote_member, 'emit');
                    remote.pc.ontrack(event);
                    return Promise.all([expect(remoteEmitMock).to.not.be.called,
                        expect(remote.stream).to.be.equal('stream')
                    ]);

                })
                it('should call onicecandidate', function() {
                    var remote = conversation.remoteMembers[0];
                    var p = new Promise(function(resolve, reject) {
                        sandbox.stub(media, '_onIceCandidate').callsFake(function() {
                            resolve();
                        });
                        remote.pc.onicecandidate();
                    });
                    return p;
                })
            })
        })

        describe('_handleParticipantRtcTerminate called', function () {

            var media;
            var sandbox;
            var conversation;
            beforeEach(function() {
                var application = {
                    me: {
                        id: 'my user id'
                    },
                    session: {
                        log: {
                            debug: function() {}
                        },
                        sendRequest: function() {}
                    },
                    activeStream: {
                        rtc_id: 'rtc_id'
                    }
                };
                conversation = new Conversation(application);
                conversation.id = 'id';
                conversation.me = {
                    id: 'me.id'
                };
                media = new Media(conversation);
                media.application.session.config = {
                    iceServers: {
                        urls: 'stun:stun.l.google.com:19302'
                    }
                }
                sandbox = sinon.sandbox.create();
            });

            afterEach(function() {
                sandbox.restore()
            })

            describe('when rtc:terminate event is called', function () {
                var emit;
                beforeEach(function() {
                    emit = sandbox.stub();
                    conversation.remoteMembers = [
                        {
                            remote_member_id: 'remote_member_id',
                            remote_member: {
                                emit: emit
                            }
                        }
                    ];
                    conversation.members['member_id'] = {};
                    var event = {
                        body: {
                            member_id: 'remote_member_id'
                        }
                    }
                    media._handleParticipantRtcTerminate( event);
                });

                it('should remove participant from remoteMembers array', function () {
                    return expect(conversation.remoteMembers).to.be.empty;
                })

                it('should call remote_member.emit', function () {
                    return expect(emit).to.be.calledOnce;
                });
            })

            describe('when rtc:terminate event is called with invalid params', function () {
                var emit;
                beforeEach(function() {
                    emit = sandbox.stub();
                    conversation.remoteMembers = [
                        {
                            remote_member_id: 'remote_member_id',
                            remote_member: {
                                emit: emit
                            }
                        }
                    ];
                    conversation.members['member_id'] = {};
                    var event = {
                        body: {
                        }
                    }
                    media._handleParticipantRtcTerminate(event);
                });

                it('should not call remote_member.emit', function () {
                    return expect(emit).to.not.be.called;
                });
            })

            describe('when rtc:terminate event is called with invalid member id', function () {
                var emit;
                beforeEach(function() {
                    emit = sandbox.stub();
                    conversation.remoteMembers = [
                        {
                            remote_member_id: 'remote_member_id',
                            remote_member: {
                                emit: emit
                            }
                        }
                    ];
                    conversation.members['member_id'] = {};
                    var event = {
                        body: {
                            member_id: 'remote_member_id1'
                        }
                    }
                    media._handleParticipantRtcTerminate(event);
                });

                it('should not call remote_member.emit', function () {
                    return expect(emit).to.not.be.called;
                });

                it('should not remove participant from remoteMembers array', function () {
                    return expect(conversation.remoteMembers.length).to.be.equal(1);
                });
            })
        })
    });
});

describe('disable()', function() {

    var conversation;
    var sandbox;

    beforeEach(function() {
        var application = {
            me: {
                id: 'my user id'
            },
            session: {
                log: {
                    debug: function() {}
                },
                sendRequest: function(params, callback) {
                    callback({
                        type: 'rtc:terminate:success'
                    });
                }
            }
        };
        conversation = new Conversation(application);
        sandbox = sinon.sandbox.create();
        conversation.me = {
            id: 'some_id'
        }
    });

    afterEach(function() {
        sandbox.restore();
    });

    it('should call send rtc:terminate request', function() {
        var sendRequestSpy = sandbox.spy(conversation.application.session, 'sendRequest');
        conversation.media.application.activeStream = {
            rtc_id: 'rtc id'
        };
        conversation.media.disable();
        return expect(sendRequestSpy).to.have.been.calledWithMatch({
            type: 'rtc:terminate'
        });
    });

    it('should resolve the promise on success', function() {
        conversation.media.application.activeStream = {
            rtc_id: 'rtc id'
        };
        var promise_disable = conversation.media.disable();
        return expect(promise_disable).to.eventually.equal('rtc:terminate:success');
    });

    it('should reject if there is no activeStream', function() {
        conversation.me = {};
        var disableAudioPromise = conversation.media.disable();
        return expect(disableAudioPromise).to.have.been.rejectedWith('error:media:not-enabled').then(function(error) {
            return Promise.all([
                expect(error).to.include.all.keys('stack', 'message', 'name'),
                expect(error.message).to.equal('type: error:media:not-enabled, description: Media is not enabled')
            ])

        })
    });

    it('should reject the promise on API error', function() {
        var application = {
            session: {
                log: {
                    debug: function() {}
                },
                sendRequest: function(params, callback) {
                    callback({
                        type: 'error:rtc:terminate'
                    });
                }
            }
        };
        var conversation = new Conversation(application);
        conversation.me = {
            id: 'some_id'
        }
        conversation.media.application.activeStream = {
            rtc_id: 'rtc id'
        };
        var promise_disable = conversation.media.disable();
        return expect(promise_disable).to.be.rejectedWith('type: error:rtc:terminate, description: ');
    });

    it('should stop the active stream objects', function() {
        conversation.media.application.activeStream = {
            rtc_id: 'rtc id',
            stream: {
                getTracks: function() {
                    return [{
                        stop: function() {}
                    }]
                }
            }
        }
        conversation.media.application.localStream = {
            getTracks: function() {
                return [{
                    stop: function() {}
                }]
            }
        };
        conversation.pc = {
            close: function() {}
        }
        var closeSpy = sandbox.spy(conversation.pc, 'close');
        //ideally we need to verify the stop, but the spy won't work, because it's instanceated on the fly
        //the next level we can check is the getTrack
        // var localStopSpy = sandbox.spy(conversation.media.application.localStream.getTracks()[0], 'stop');
        var localStopSpy = sandbox.spy(conversation.media.application.localStream, 'getTracks');
        // var activeStopSpy = sandbox.spy(conversation.media.application.activeStream.stream.getTracks()[0], 'stop');
        var activeStopSpy = sandbox.spy(conversation.media.application.activeStream.stream, 'getTracks');

        conversation.media.disable();

        return Promise.all([
            expect(localStopSpy).to.have.been.called,
            expect(activeStopSpy).to.have.been.called,
            expect(closeSpy).to.have.been.called,
            expect(conversation.media.application.activeStream.stream).to.not.exist,
            expect(conversation.media.application.activeStream.rtc_id).to.not.exist
        ])
    });
});

describe('earmuff()', function() {
    var conversation;
    var application;
    var sandbox;

    beforeEach(function() {
        application = {
            session: {
                log: {
                    debug: function() {}
                },
                sendRequest: function(params, callback) {
                    callback({
                        type: 'audio:earmuff:on:success'
                    });
                }
            }
        };
        conversation = new Conversation(application);
        conversation.id = 'conversationid';
        sandbox = sinon.sandbox.create();
        conversation.me = {
            id: 'some_id'
        }
    });

    afterEach(function() {
        sandbox.restore();
    });

    describe('on', function() {
        it('should send audio:earmuff:on request', function() {
            var sendRequestSpy = sandbox.spy(conversation.application.session, 'sendRequest');
            conversation.media.earmuff(true);
            return expect(sendRequestSpy).to.have.been.calledWithMatch({
                type: 'audio:earmuff:on',
                to: conversation.me.id,
                cid: conversation.id
            });
        });

        it('should resolve on audio:earmuff:on:success with the event', function() {
            application.session.sendRequest = function(params, callback) {
                callback({
                    type: 'audio:earmuff:on:success',
                    body: {
                        id: '1'
                    }
                });
            }
            var conversation = new Conversation(application);
            conversation.id = 'conversationid'
            conversation.me = {
                id: 'some_id'
            }
            var sayText_promise = conversation.media.earmuff(true);
            return expect(sayText_promise).to.have.been.fulfilled;
        });
    });

    describe('off', function() {
        it('should send media:earmuff:off request', function() {
            var sendRequestSpy = sandbox.spy(conversation.application.session, 'sendRequest');
            conversation.media.earmuff(false);
            return expect(sendRequestSpy).to.have.been.calledWithMatch({
                type: 'audio:earmuff:off',
                to: conversation.me.id,
                cid: conversation.id
            });
        });

        it('should resolve on audio:earmuff:off:success with the event', function() {
            application.session.sendRequest = function(params, callback) {
                callback({
                    type: 'audio:earmuff:off:success',
                    body: {
                        id: '1'
                    }
                });
            }
            var conversation = new Conversation(application);
            conversation.id = 'conversationid'
            conversation.me = {
                id: 'some_id'
            }
            var sayText_promise = conversation.media.earmuff(false);
            return expect(sayText_promise).to.have.been.fulfilled;
        });
    });

    it('should reject the promise on API error', function() {
        application.session.sendRequest = function(params, callback) {
            callback({
                type: 'error:audio:earmuff'
            });
        }
        var conversation = new Conversation(application);
        conversation.id = 'conversationid'
        conversation.me = {
            id: 'some_id'
        }
        var sayText_promise = conversation.media.earmuff(true);
        return expect(sayText_promise).to.have.been.rejectedWith('type: error:audio:earmuff, description: ');
    })
});

describe('sayText()', function() {
    var conversation;
    var application;
    var sandbox;

    beforeEach(function() {
        application = {
            session: {
                log: {
                    debug: function() {}
                },
                sendRequest: function() {}
            }
        };
        conversation = new Conversation(application);
        sandbox = sinon.sandbox.create();
    });

    afterEach(function() {
        sandbox.restore();
    });

    it('should send audio:say request', function() {
        var params = {
            text: 'hi',
            voice_name: 'voice name',
            level: 2,
            queue: true,
            loop: true
        }
        var sendRequestSpy = sandbox.spy(conversation.application.session, 'sendRequest');
        conversation.media.sayText(params);
        return expect(sendRequestSpy).to.have.been.calledWithMatch({
            type: 'audio:say',
            body: params
        });
    });

    it('should resolve on audio:say:success with the event', function() {
        application.session.sendRequest = function(params, callback) {
            callback({
                type: 'audio:say:success',
                body: {
                    id: '1'
                }
            });
        }
        var conversation = new Conversation(application);
        var sayText_promise = conversation.media.sayText({});
        return expect(sayText_promise).to.have.been.fulfilled;
    });

    it('should reject the promise on API error', function() {
        application.session.sendRequest = function(params, callback) {
            callback({
                type: 'error:audio:say',
                body: {
                    id: '1'
                }
            });
        }
        var conversation = new Conversation(application);
        var sayText_promise = conversation.media.sayText({});
        return expect(sayText_promise).to.have.been.rejectedWith('type: error:audio:say, description: ');
    })
});

describe('mute()', function() {
    var conversation;
    var application;
    var sandbox;

    beforeEach(function() {
        application = {
            session: {
                log: {
                    debug: function() {}
                },
                sendRequest: function(params, callback) {
                    callback({
                        type: 'audio:mute:on:success'
                    });
                }
            }
        };
        conversation = new Conversation(application);
        conversation.id = 'conversationid';
        sandbox = sinon.sandbox.create();
        conversation.me = {
            id: 'some_id'
        }
    });

    afterEach(function() {
        sandbox.restore();
    });

    describe('on', function() {
        it('should send audio:mute:on request', function() {
            var sendRequestSpy = sandbox.spy(conversation.application.session, 'sendRequest');
            conversation.media.mute(true);
            return expect(sendRequestSpy).to.have.been.calledWithMatch({
                type: 'audio:mute:on',
                to: conversation.me.id,
                cid: conversation.id
            });
        });

        it('should resolve on audio:mute:on:success with the event', function() {
            application.session.sendRequest = function(params, callback) {
                callback({
                    type: 'audio:mute:on:success',
                    body: {
                        id: '1'
                    }
                });
            }
            var conversation = new Conversation(application);
            conversation.id = 'conversationid'
            conversation.me = {
                id: 'some_id'
            }
            var sayText_promise = conversation.media.mute(true);
            return expect(sayText_promise).to.have.been.fulfilled;
        });
    });

    describe('off', function() {
        it('should send audio:mute:off request', function() {
            var sendRequestSpy = sandbox.spy(conversation.application.session, 'sendRequest');
            conversation.media.mute(false);
            return expect(sendRequestSpy).to.have.been.calledWithMatch({
                type: 'audio:mute:off',
                to: conversation.me.id,
                cid: conversation.id
            });
        });

        it('should resolve on audio:mute:off:success with the event', function() {
            application.session.sendRequest = function(params, callback) {
                callback({
                    type: 'audio:mute:off:success',
                    body: {
                        id: '1'
                    }
                });
            }
            var conversation = new Conversation(application);
            conversation.id = 'conversationid'
            conversation.me = {
                id: 'some_id'
            }
            var mute_promise = conversation.media.mute(false);
            return expect(mute_promise).to.have.been.fulfilled;
        });
    });

    it('should reject the promise on API error', function() {
        application.session.sendRequest = function(params, callback) {
            callback({
                type: 'error:audio:mute'
            });
        }
        var conversation = new Conversation(application);
        conversation.id = 'conversationid'
        conversation.me = {
            id: 'some_id'
        }
        var sayText_promise = conversation.media.mute(true);
        return expect(sayText_promise).to.have.been.rejectedWith('type: error:audio:mute, description: ');
    })
});


describe('Instance', function() {
    var audioConversation;
    var sandbox;

    beforeEach(function() {
        audioConversation = new Conversation();
        sandbox = sinon.sandbox.create();
    });

    afterEach(function() {
        sandbox.restore();
    });

    it('exists in Conversation', function() {
        return expect(audioConversation.media).to.be.an.instanceOf(Media);
    });

    describe('in one Conversation instance', function() {
        it('the conversation instance should be shared', function() {
            audioConversation.test = 'value';
            return expect(audioConversation.media.parentConversation.test).to.equal(audioConversation.test);
        });
        it('the audio instance should be shared', function() {
            audioConversation.media.test = 'value';
            return expect(audioConversation.media.test).to.equal(audioConversation.media.parentConversation.media.test);
        });
    })

    describe('2 instances of Conversation Objects', function() {
        var secondAudioConversation;
        beforeEach(function() {
            secondAudioConversation = new Conversation();
        })

        it('should not share the conversation object in Media', function() {
            audioConversation.test = 'value';
            return expect(secondAudioConversation.media.parentConversation.test).to.not.equal(audioConversation.test);
        });

        it('should not share the Media object', function() {
            audioConversation.media.test = 'value';
            return expect(secondAudioConversation.media.test).to.not.equal(audioConversation.media.test);
        });
    });

    //move these to hermetic suite
    describe.skip('webRTC', function() {

        var conversation;

        beforeEach(function() {
            var application = {
                me: {
                    rtc_id: 'received_rtc_id',
                    id: 'my user id'
                },
                session: {
                    log: {
                        debug: function() {}
                    },
                    sendRequest: function(params, callback) {
                        callback({
                            type: 'rtc:terminate:success'
                        });
                    }
                }
            };
            conversation = new Conversation(application);
            conversation.media.application.session.config = {
                iceServers: {
                    urls: 'stun:stun.l.google.com:19302'
                }
            };
            conversation.me = {
                id: 'some_id'
            };
            global.navigator = {
                mediaDevices: {
                    getUserMedia: function() {
                        return Promise.resolve()
                    }
                }
            };
            global.RTCSessionDescription = function() {};
            global.RTCPeerConnection = function() {
                return {
                    addStream: function() {},
                    ontrack: function() {},
                    createOffer: function() {},
                    oniceconnectionstatechange: function() {},
                    onicegatheringstatechange: function() {},
                    setRemoteDescription: function(param, callback) {
                        callback();
                    }
                };
            }
        });
        //TODO find a better way to stub/spy on all the required parts
        it('should be triggered when our member is left', function() {
            var disableSpy = sandbox.spy(conversation.media, 'disable');
            setTimeout(function() {
                conversation.emit('rtc:answer', {
                    body: {
                        answer: 'sdp'
                    }
                })
            }, 100);

            return conversation.media.enable().then(
                function() {
                    conversation.emit('member:left', {
                        user: {
                            id: conversation.media.application.me.id
                        }
                    });
                    return expect(disableSpy).to.have.been.called;
                }
            );
        });
        //TODO find a way to test this
        it.skip('should send rtc:new request', function() {
            var sendRequestSpy = sandbox.spy(conversation.application.session, 'sendRequest');
            conversation.media.enable();
            return expect(sendRequestSpy).to.have.been.called
        });
    });
});

describe('Object', function() {
    var conversation;

    beforeEach(function() {
        var application = {
            session: {
                sendRequest: function() {}
            }
        };
        conversation = new Conversation(application);
    });

    it('should be created by calling new', function() {
        var media = new Media(conversation);
        return expect(media).to.be.an.instanceOf(Media);
    });
});